# Files and Directories

Previous chapter was related to manage files through I/O functions for regular files (opening file, read it, writing). Now we will look to features of file system and properties of a file. We'll start with stat functions, and go through each m<F2>ember of the stat structure, looking the attributes. Then we'll describe each of functions that modify these attributes: change owner, change permissions, and so on. We'll also look at the structure of a UNIX file system and symbolic links. Finally we will talk about functions that operate on directories, and we develop a function that descends through a directory hierarchy.

## stat, fstat, fstatat and lstat Functions

discussion in this chapter centers on four stat functions and information they return:

	#include <sys/stat.h>

	int stat(const char *restrict pathname, struct stat *restrict buf);
	int fstat(int fd, struct stat *buf);
	int lstat(const char *restrict pathname, struct stat *restrict buf);
	int fstatat(int fd, const char *restrict pathname, struct stat *restrict buf, int flag);
		
		All four return: 0 if OK, -1 on error

Given pathname, stat function returns structure of information about named file. fstat function obtains information about file that is already opened on file descriptor fd (better to avoid TOCTTOU vulnerabilities). lstat function similar to stat, but when named file is symbolic link, lstat returns information about symbolic link, not file referenced by symbolic link.
fstatat function provides a way to return file statistics for a pathname relative to open directory represented by fd argument. flag argument controls whether symbolic links are followed; when AT_SYMLINK_NOFOLLOW flag is set, fstatat will not folllow symbolic links, rather returns information about the link itself. Otherwise, default is to follow symbolic links, returning information about the file to which symbolic link points. If fd argument has value AT_FDCWD and pathname argument is relative pathname, then fstatat evaluates pathname argument relative to "current working directory". If pathname is absolute pathname, then fd argument is ignored. These two cases, fstatat behaves like wither stat or lstat, depending on value of flag.

buf argument is a pointer to a structure that we must supply. Functions fill in structure. Definition of the structure can differ among implementations but looks like:
	struct stat {
		mode_t		st_mode;	/* file type & mode (permissions) */
		ino_t		st_ino;		/* i-node number (serial number) */
		dev_t		st_dev;		/* device number  (file system) */
		dev_t		st_rdev;	/* device number for special files */
		nlink_t		st_nlink;	/* number of links */
		uid_t		st_uid;		/* user ID of owner */
		gid_t		st_gid;		/* group ID of owner */
		off_t		st_size;	/* size in bytes, for regular files */
		struct timespec st_atim;	/* time of last access */
		struct timespec st_mtim;	/* time of last modification */
		struct timespec st_ctim;	/* time of last file status change */
		blksize_t	st_blksize;	/* best I/O block size */
		blkcnt_t	st_blocks;	/* number of dis blocks allocated */
	};
	st_rdev, st_blksize, and st_blocks fields are not required by POSIX.1. They are defined as part of XSI option in single UNIX Specification.

timespec structure type defines time in terms of seconds and nanoseconds. It includes at least the following fields:

	time_t tv_sec;
	long tv_nsec;

	Prior to 2008 version, the time fields were named st_atime, st_mtime, and st_ctime, and were time_t (expressed in seconds). timespec structure enables higher-resolution timestamps. Old names can be defined in terms of tv_sec member for compatibility. Example, st_atime can be defined as st_atim.tv_sec.

Most members of stat structure are specified by primitive system data type. Biggest user of stat functions is probably "ls -l" command to get information about a file.

## File types

We've talked about two types of files: regular files and directories. Most files on UNIX system are either regular or directories, but there are additional:
	1. Regular file. Most common, contains data of some form. No distinction to UNIX kernel whether this data is text or binary. Any interpretation of contents of regular file is left to application processing the file. One exception are binary executable files. As kernel must understand format to execute it. So all binary executable files conform to a format that allows kernel to identify where to load program's text and data.
	2. Directory file. File that contains names of other files and pointers to information on these file. Any process that has read permission for a directory can read contents of directory, but only kernel can write directly to a directory file. Processes must use functions described later to make changes to a directory.
	3. Block special file. Type of file providing buffered I/O access in fixed-size units to devices such as disk drives. (FreeBSD no longer supports block special files. All access to devices is through characters special interface).
	4. Character special file. Type of file providing unbuffered I/O access in variable-sized units to devices. All devices on a system are block special or character special files.
	5. FIFO. Type of file used for communication between processes. Sometimes called named pipe. We describe FIFOs in Chapter 15.
	6. Socket. Type of file used for network communication between processes. Socket can also be used for non-network communication between processes on single host. We use socket for interprocess communication in Chapter 16.
	7. Symbolic link. Type of file that points to another.

Type of a file is encoded in st_mode member of stat structure. We can determine file type with macros:
	
	S_ISREG()	Regular file
	S_ISDIR()	Directory file
	S_ISCHR()	Character special file
	S_ISBLK()	Block special file
	S_ISFIFO()	pipe or FIFO
	S_ISLNK()	Symbolic link
	S_ISSOCK()	socket

Parameter of each macro is the st_mode member.

POSIX.1 allows implementations to represent interprocess communication (IPC) objects, suck as message queues and semaphores, as files. Next macros allow us to determine type of IPC object from stat structure. Instead of taking st_mode member as argument, these macros differ from previous in that their argument is a pointer to stat structure:

	S_TYPEISMQ()	message queue
	S_TYPEISSEM()	semaphore
	S_TYPEISSHM()	shared memory object

Discussed most in chapter 15. But None of implementations of these objects are as files in this book.

Example: type_printer.c program which prints type of file for each command-line argument. 

Historically, early versions of UNIX System didn't provide S_ISxxx macros. Instead we had to AND the st_mode value with S_IFMT and then compare result with constants whose names are S_IFxxx. Most system define this mask and related constants in file <sys/stat.h>. If we examine this file, we'll find the S_ISDIR macro defined something like:
	
	#define	S_ISDIR(mode)	(((mode) & S_IFMT) == S_IFDIR)

Regular files are predominant, but it is interesting to see what percentage of files on given system are of each file type.

## Set-User-ID and Set-Group-ID

Every process has six or more IDs associated with it:

	real user ID & real group ID	=	who we really are
	effective user ID, effective group ID & supplementary group IDs	=	used for file access permission checks
	saved set-user-ID & saved set-group-ID		=	saved by exec functions

	* real user ID and real group ID identify who we really are. Taken from our entry in password file when we log in. Normally, values don't change during a login session, although there are ways for a superuser process to change them.
	* effective user ID, effective group ID, and supplementary group IDs determine our file access permissions.
	* Saved set-user-ID and saved set-group-ID contain copies of effective user ID and effective group ID, respectively when a program is executed. These were optional in older versions of POSIX. Application can test for constant _POSIX_SAVED_IDS at compile time or can call sysconf with _SC_SAVED_IDS argument at runtime, to see whether implementation supports this feature.

Normally, effective user ID equals real user ID, and effective group ID equals to real group ID. 
Every file has owner and a group owner. Owner is specified by st_uid member of stat structure; group owner, by st_gid member.
When we execute a program file, usually happen what we said about user and group ID. However we can set a special flag in file's mode word (st_mode) that says, "When file is executed, set effective user ID of process to be owner of the file (st_uid)." We can set another bit in file's mode word that causes effective group ID to be group owner of file (st_gid). These two bits in file's mode word are called set-user-ID bit and set-group-ID bit.

If owner of file is superuser and if file's set-user-ID bit is set, while program file is running as process, it has superuser privileges. And happens regardless of real user ID of process that executes the file. As example, UNIX System program that allows anyone to change his or her password, passwd(1), is set-user-ID program. Required so that program can write new password to file, typically /etc/passwd or /etc/shadow writable only by superuser. These kind of programs must be written carefully. We'll discuss these types of programs in more detail in Chapter 8.

Returning to stat function, set-user-ID bit and set-group-ID bit are contained in file's st_mode value. These two bits can be tested against constants S_ISUID and S_ISGID respectively.

## File Access Permissions

st_mode value also encodes access permission bits for file. When we say file, any type. There are nine permission bits for each file, divided into three categories:

	S_IRUSR		user-read
	S_IWUSR		user-write
	S_IXUSR		user-execute

	S_IRGRP		group-read
	S_IWGRP		group-write
	S_IXGRP		group-execute

	S_IROTH		other-read
	S_IWOTH		other-write
	S_IXOTH		other-execute

Term user in first three rows = owner of file. chmod command, typically used to modify these nine permission bits, allows us to specify 'u' for user (owner), g for group, and o for other. We'll use terms user, group and other, to be consistent with chmod.
The three categories - read, write, and execute - are used in various ways by different functions. We'll summarize them, and return when we describe the actual functions:

	* first rule  is whenever we want to open any type of file by name, we must have execute permission in each directory mentioned in the name, including current directory. This is why execute permission bit for directory is often called search bit.
	Example opening file /usr/include/stdio.h needs permission of execute in /, /usr and /usr/include, also necessary have specific permission in stdio.h depending we are opening file in read-only or read-write, etc.
	If we are in /usr/include means we need execute permission in current directory to open file stdio.h.
	Read permission for a directory and execute permission for a directory mean different things. Read permission lets us read directory, obtaining list of all filenames in directory. Execute permission lets us pass through directory when it's a component of a pathname we are trying to access.
	Another example of implicit directory PATH environment variable, specifies directory that does not have execute permission enabled. This case, shell will never find executable files in that directory.
	* read permission for a file determines whether we can open existing file for reading: O_RDONLY and O_RDWR flags for open fnuction.
	* Write permission for a file determines whether we can open existing file for writing: O_WRONLY and O_RDWR flags for open function.
	* We must have write permission for a file to specify O_TRUNC flag (as remove content).
	* We cannot create new file in directory unless we have write permission and execute permission in directory.
	* To delete existing existing file, we need write permission and execute permission in directory containing the file. We do not need read permission or write permission for file itself.
	* Execute permission for a file must be on if we want to execute file using any of seven exec functions. File also has to be a regular file.

File access tests that kernel performs each time a process opens, creates, or deletes a file depend on owners of file (st_uid and st_gid), effective IDs of process (effective user ID and effective group ID), and supplementary group IDs of the process, if supported. Two owner IDs are properties of the file, whereas two effective IDs and supplementary group IDs are properties of the process. Test performed by kernel are as follows:
	* If effective user ID of process is 0 (superuser), access is allowed. This gives superuser free rein throughout entire file system.
	* If effective user ID of process equals owner ID of file (process owns file), access is allowed if appropiate user access permission bit is set. Otherwise, permission is denied. By appropiate access permission bit, we mean that if process is opening file for reading, user-read bit must be on. Same with writing and executing.
	* If effective group ID of process or one of supplementary group IDs of process equals group ID of the file, access is allowed if appropiate group access permission bit is set. Otherwise, permission is denied.
	* If appropiate other access permission bit is set, access is allowed. Otherwise, permission is denied.

These steps are tried in sequence. Note if process owns file (step 2), access is granted or denied based only on user access permissions; group permissions are never looked at. Similarly, if process does not won file but belongs to appropiate group, access is granted or denied based only on group access permissions; other permissions are not looked at.

## Ownership of New Files and Directories

We didn't say values assigned to created files (by open or creat) for the user ID and group ID. We'll see how to create a directory with mkdir. Rules for ownership of directory are the same than for a file.
User ID of new file is set to effective user ID of process. POSIX.1 allows an implementation to choose one of following options to determine group ID of new file:
	* Group ID of new file can be effective group ID of process.
	* Group ID of new file can be group ID of directory in which file is being created.
(FreeBSD 8.0 and Mac OS X 10.6.8 always copy new file's group ID from directory. Several Linux file system allow choice between two options to be selected using a mount command option, Linux 3.2.0 and Solaris 10 determine group ID if bit SGID (set-group-ID) is set new file's group ID is copied from directory; otherwise, new file's group ID is set to effective group ID of process).

Using second option, inheriting directory's group ID, assures us all files and directories created in that directory will have same group ID as directory. Group ownership of files and directories will then propagate down the hierarchy from that point.

## access and faccessat Functions

When we open a file, kernel performs its access test based on effective user and group IDs. Sometimes, a process wants to test accessibility based on real user and group IDs. Useful when a process is running as someone else, using set-user-ID or set-group-ID.
Even though  a process might be set-user-ID to root, it might still want to very that real user can access a given file. access and faccessat functions base their test on real user and group IDs.

	#include <unistd.h>
	int access(const char *pathname, int mode);
	int faccessat(int fd, const char *pathname, int mode, int flag);
		Both return: 0 if OK, -1 on error.


mode is either value F_OK to test if file exists, or bitwise OR of any of next flags:
	
	R_OK	test for read permission
	W_OK	test for write permission
	X_OK	test for execute permission

faccessat function behaves like access when pathname argument is absolute or when fd argument has value AT_FDCWD and pathname argument is relative. Otherwise, faccessat evaluates pathname relative to open directory referenced by fd argument.
flag argument can be used to change behaviour of faccessat. If AT_EACCESS flag is set, access checks are made using effective user and group IDs of calling process instead of real user and group IDs.

Example: real_user_check.c, program that checks access of a file with the real user ID and real group ID using access call.
	$ ./real_user_check /etc/spwd.db
	file exist
	access error for /etc/spwd.db: permission denied
	open error for /etc/spwd.db: permission denied
	$ sudo su
	# chown root real_user_check # set real_user_check ownser as root
	# chmod 4755 real_user_check # set SUID
	# exit
	$ ./real_user_check /etc/spwd.db
	file exist
	access error for /etc/spwd.db: permission denied
	open for reading OK

As we can see above, even with SUID, the function access uses the real user ID to check the access. 
In preceding example and in Chapter 8, we'll sometimes switch to become superuser to demonstrate how something works. If you're on multiuser system and do not have superuser permission, you won't be able to duplicate these examples completely.

## umask Function

Described the nine permission bits associated with every file, we can describe file mode creation mask associated with every process.
unask function sets file mode creation mask for process and returns previous value. (One of the few function that doesn't have error return).

	#include <sys/stat.h>
	
	mode_t umask(mode_t cmask);
		Returns: previous file mode creation mask
	
cmask argument is formed as bitwise OR of any of nine constants from S_IRUSR, S_IWUSR, and so on.
File mode creation mask used whenever process creates new file or new directory (If we remember from chapter 3 in open and creat functions, both accept mode argument that specifies new file's access permission bits). We will see later how to create new directory. Any bits "on" in file mode creation mask are turned off in file's mode.

Example: create_files_umask.c program that creates two files: one with umask of 0 (all permissions turned on), and one with umask that disables all group and other permission bits.
If we check the umask and execute the program we get the next information:
	$ umask # check current file mode creation mask
	0022
	$ ./create_files_umask
	$ ls -l foo bar
	-rw-------  1 Fare9  Fare9     0B Feb  3 20:37 bar
	-rw-rw-rw-  1 Fare9  Fare9     0B Feb  3 20:37 foo

Most UNIX users never deal with umask value. They use the one set on login by shell's start-up file. When writing programs that create new files, if we want to ensure specific access permission bits are enabled, we must modify umask value while process is running. Example, if we want to ensure that anyone can read a file, we should set umask to 0. Otherwise, umask value is the one from system when process started.
We used shell's umask command to print file mode creation mask before we run program and after it completes. Changing file mode creation mask of a process doesn't affect mask of parent. All shells have a built-in umask command to set or print current file mode creation mask.
Users can set umask value to control default permissions on files they create. Value is expressed in octal, one bit representing one permission to be masked off. Permission can be denied setting corresponding bits. Some common umask values are 002 (prevent others from writing our files, or 022 prevent group members and others writing our files.
	
	Mask bit	Meaning
	0400		user-read
	0200		user-write
	0100		user-execute
	0040		group-read
	0020		group-write
	0010		group-execute
	0004		other-read
	0002		other-write
	0001		other-execute

Single UNIX specification requires that umask command support symbolic mode of operation. Unlike octal formta, symbolic format specifies permission are to be allowed (clear in file creation mask) instead of which one are to be denied (set in file creation mask). Check both forms below:

	$ umask		# print current file mode creation mask
	002
	$ umask -S	# print symbolic form
	u=rwx,g=rwx,o=rx
	$ umask 027	# change file mode creation mask
	$ umask -S
	u=rwx,g=rx,o=

## chmod, fchmod and fchmodat Functions

these functions allow us to change file access permissions for existing file.

	# include <sys/stat.h>

	int chmod (const char *pathname, mode_t mode);
	int fchmod (int fd, mode_t mode);
	int fchmodat (int fd, const char *pathname, mode_t mode, int flag);
		return: 0 if OK, -1 on error

chmod operates on specified file, and fchmod operates on file already opened. fchmodat behaves like chmod when pathname argument is absolute or when fd argument has value AT_FDCWD and pathname argument is relative. Otherwise, fchmodat evaluates pathname relative to open directory referenced by fd argument. flag argument can be used to change behaviour of fchmodat (when AT_SYMLINK_NOFOLLOW flag is set, chmodat doesn't follow symbolic links).
To change permission bits of file, effective user ID of process must be equal to owner ID of file, or process must have superuser permissions. mode is specified as bitwise OR of constants:

	mode		Description
	S_ISUID		set-user-ID on execution
	S_ISGID		set-group-ID on execution
	S_ISVTX		saved-text (sticky bit)

	S_IRWXU		read, write, and execute by user (owner)
	  S_IRUSR	read by user (owner)
	  S_IWUSR	write by user (owner)
	  S_IXUSR	execute by user (owner)
	
	S_IRWXG		read, write, and execute by group
	  S_IRGRP	read by group
	  S_IWGRP	write by group
	  S_IXGRP	execute by group
	
	S_IRWXO		read, write, and execute by others
	  S_IROTH	read by others
	  S_IWOTH	write by others
	  S_IXOTH	execute by others

These are the same bits that we explained previously but we've added the S_ISUID and S_ISGID, the S_ISVTX and the combination of the three permissions S_IRWXU, S_IRWXG, S_IRWXO.

Example: change_file_permissions.c In this file we will modify "bar" file previously created permissions (-rw------) for new one (rw-r--r--).

So if we check files and execute:

	$ ls -lah bar foo
	-rw-------  1 Fare9  Fare9     0B Feb  3 20:37 bar
	-rw-rw-rw-  1 Fare9  Fare9     0B Feb  3 20:37 foo
	$ ./change_file_permissions
	$ ls -lah bar foo
	-rw-r--r--  1 Fare9  Fare9     0B Feb  3 20:37 bar
	-rw-rwSrw-  1 Fare9  Fare9     0B Feb  3 20:37 foo

So as we can see, we've modified permissions for "bar" and for foo we've modified files adding set-group-ID permission from previous mask of permission.

Note that time and date listed by "ls" command didn't change after program execution. chmod function updates only time that i-node was last changed. By default, ls -l lists time when contents of file were last modified (note difference between i-node time last modified and file content last modified).

chmod functions clear two of permission bits under following conditions:
	* On systems, suck as Solares, if we try to set sticky bit (S_ISVTX) on regular file and do not have superuser privileges, sticky bit in mode is automatically turned off. To prevent malicious users from setting sticky bit and affecting system performance, only superuser can set sticky bit of regular file.
	* Group ID of newly created file might potentially be a group that the calling process does not belong to. It's possible for group ID of new file to be group ID of parent directory. If the group ID of new file does not equal either the effective group ID of the process or one of the process's supplementary group IDs and if process does not have superuser privileges, then set-group-ID bit is automatically turned off. Prevents user from creating a set-group-ID file owned by group that user doesn't belong to.

## Sticky bit

Versions of UNIX System that predated demand paging, bit was known as sticky bit. If it was set for executable program file, first time program was executed, copy of program's text was saved in swap area when process terminated (code part). Program would then load into memory more quickly next time it was executed, because swap area was handled as contiguous file. Sticky bit was set for common application programs (text editor and passes of C compiler).
Right now this bit is not necessary with virtual memory and faster file system.
On contemporary systems, use of sticky bit has been extended. Single UNIX Specification allows sticky bit to be set for directory. If bit is set for directory, file in directory can be removed or renamed only if user has write permission for directory and meets one of following criteria:
	* Owns the file
	* Owns the directory
	* Is the superuser
/tmp and /var/tmp are candidates for sticky bit (directories in which any user can typically create files). Permissions for these two directories are often read, write, and execute for everyone. But users should not be able to delete or rename files owned by others. (Latest versions of UNIX System referred this as saved-text bit).

## chown, fchown, fchownat and lchown Functions

functions allow us to change a file's user ID and group ID, but if either of arguments owner or group is -1, corresponding ID is left unchanged.

	#include <unistd.h>

	int chown(const char *pathname, uid_t owner, gid_t group);
	int fchown(int fd, uid_t owner, gid_t group);
	int fchownat(int fd, const char *pathname, uid_t owner, gid_t group, int flag);
	int lchown(const char *pathname, uid_t owner, gid_t group);
		return: 0 if OK, -1 ok error

Four functions operate similar unless referenced file is a symbolic link. That case, lchown and fchownat (with AT_SYMLINK_NOFOLLOW flag set) change owners of symbolic link itself, not file pointed to by symbolic link.
fchown changes ownership of open file referenced by fd argument. Since it operates on file already open, it can't be used to change ownership of symbolic link.
fchownat behaves like chown or lchown when pathname argument is absolute or when fd argument has value AT_FDCWD and pathname argument is relative. Then if flag is AT_SYMLINK_NOFOLLOW it will act as lchown and as chown other case.
Historically BSD-based systems enforced restriction that only superuser can change ownership of a file. System V however, has allowed all users to change ownership of any files they own.

We can check constant _POSIX_CHOWN_RESTRICTED, so if the constant is in effect for specified file:
	* Only superuser process can change user ID of file.
	* Nonsuperuser process can change group ID of file if process owns the file (effective user ID equals user ID of file), owner is specified as -1 or equals user ID of file, and group equals either effective group ID of process or one of process's supplementary group IDs.

## File Size

st_size member of stat structure contains size of file in bytes. Field is meaningful only for regular files, directories and symbolic links.
For a regular file, file size of 0 is allowed. We'll get an end-of-file indication on first read of file. For a directory, file size is multiple of a number, such as 16 or 512 (we'll see it).
For symbolic link, file size is number of bytes in filename (symbolic link contains path to file, also symbolic links do not contain normal C null byte at the end of name).
Most contemporary UNIX systems provide fields st_blksize and st_blocks. First is preferred block size for I/O for file, and latter is actual number of 512-byte blocks allocated. Remember from chapter 3 that we encountered minimum amount of time required to read file when we used st_blksize for read operations. Standard I/O library (chapter 5), also tries to read or write st_blksize bytes at a time.

- Holes in a file
Regular file can contain "holes". Holes are creted by seeking past the current end of file and writing some data. read function returns data bytes of 0 for any byte positions that have not been written. If we execute "wc -c" in a file with holes, we will receive all characters read (counting holes too). That's the size "ls -l" give us too. But if we execute "du -s" in that file, we will receive the number of 512-byte blocks (less than size of file).

But if we create a copy using "cat file > file_copy", holes will be copied as null bytes, "ls -l" will return same size for both, but "du -s" will return a bigger number of blocks for the copy version will be bigger.

## File Truncation

We would like to truncate file by chopping off data at the end of file. Emptying a file, which we can do with O_TRUNC flag to open, is special case of truncation.

	#include <unistd.h>

	int truncate(const char *pathname, off_t length);
	int ftruncate(int fd, off_t length);
		0 if OK, -1 on error

Both truncate existing file to length bytes. If previous size was greater than length, data beyond length is no longer accessible. If previous size was less than length, file size will increase and data between old end of file and newer will read as 0 (hole is probably created in the file).
ftruncate is used when we need to empty a file after obtaining a lock on the file.
