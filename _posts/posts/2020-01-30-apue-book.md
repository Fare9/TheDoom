---
layout: post
title: Advanced Programming in the UNIX Environment
date: 2020-01-30 00:12:00
categories: posts
comments: true
en: true
description: Summary Post about Advanced Programming in the UNIX Environment
keywords: "ELF, Unix, POSIX, C, Programming"
authors:
    - Fare9
---

# Advanced Programming in the UNIX Environment (APUE)

## Chapters

1. [Chapter1](#chapter1)
2. [Chapter2](#chapter2)
3. [Chapter3](#chapter3)
4. [Chapter4](#chapter4)
5. [Chapter5](#chapter5)

# <a name="chapter1"></a> 1 - UNIX System Overview

**Makefile for this chapter [Makefile](https://github.com/K0deless/TheDoom/blob/master/code/APUE/chapter1/Makefile)**

## Introduction
Operating systems offer services for programs they run. Executing a new program, opening a file, reading a file, allocating a memory region, etc.

## Unix Architecture
Operating system software that controls the hardware resources of computer, provides environment where programs can run. This software is called the kernel.
Interface to kernel is a layer of software called "system calls". And libraries of common functions are built on top of system call interface, application are free to use both. Shell is special application that provides interface for running other applications.

Operating system = kernel + system utilities, applications, shells, libraries.

## Login In

**Login Name:**

At login we give login name and password. System checks name and password in the file /etc/shadow. Our entry in the /etc/shadow is composed by different fields separated by colon: login name, encrypted password, user ID, group ID, comment field, home directory, and shell.
We'll see in different chapters how to access to the files.

## Shells
command line interpreter that reads user input and executes commands. User input to a shell is from the terminal (interactive shell) or from a file (shell script). Common shells: bourne shell (/bin/sh), Bourne-again shell (/bin/bash), C shell (/bin/csh), Korn Shell (/bin/ksh), TENEX C shell (/bin/tcsh).
Depending on system, one or another shell will be implemented.

## Files and Directories

**File System**

UNIX file system is hierarchical arrangement of directories and files. Everything starts in directory root (/).
Directory = file that contains directory entries. Each directory entry as containing a filename along with structure of information describing the attributes of the file. The attributes of file are: type of file (regular or directory), size of file, owner of file, permissions for file (whether other users may access this file), and when the file was last modified. "stat" and "fstat" functions return structure of information containing all attributes of a file.
In chapter 4, we'll see distinction between logical view of directory entry and way it's stored on disk. Most UNIX file systems don't store attributes in directory entries themselves, because of difficulty of keeping them in synch when file has multiple hard links.

*Filename* = names in directory. Only two characters cannot be in filename are slash (/) and null. Slash separates filenames that form pathname and null character terminates pathname. Good practice restrict characters in a filename to subset of normal printing characters. POSIX.1 recommends restricting filenames to following characters: letters (a-z,A-Z), numbers (0-9), period (.), dash (-) and underscore (\_).

Two filenames created when new directory is created: . (dot) and .. (dot-dot). Dot refers to current directory, dot-dot refers to parent directory. In "root" dot and dot-dot are the same.

*Pathname* = one or more filenames, separated by slashes, optionally starting with a slash, forms a "pathname". Pathname that begins with slash called "absolute pathname"; otherwise "relative pathname". Latter one refer to files relative to current directory. Name for root of file system (/) is special-case absolute pathname that has no filename component.

Example: [my_ls.c](https://github.com/K0deless/TheDoom/blob/master/code/APUE/chapter1/my_ls.c)

In UNIX manual pages can be referenced by numbers, because more than one entry can exists, sections are normally numbered 1 through 8. For example the tool "ls" we've "copied" can be checked in manual as:

```console
    $ man 1 ls
```

or

```console
    $ man -s1 ls
```

If we name the source file as "my_ls.c" we can compile it into the default a.out with the C compiler "CC" as:

```console
    CC my_ls.c
```

From this program we can detail the next:

1. Included one APUE header apue.h. Included in almost every program in book. Header includes some standard system headers and define numerous constant and function prototypes.
2. We include system header dirent.h, to pick up function prototypes for opendir and readdir, in addition to definition of dirent structure. In some systems prototypes and definition of the structure are separated.
3. Declaration of main uses style supported by ISO C standard.
4. We take an argument from command line, argv[1], as name of the directory to list.
5. Because of actual format of directory entries varies from one UNIX to another, we use opendir, readdir and closedir to manipulate directory.
6. opendir function returns pointer to DIR structure, and we pass pointer to readdir function. We don't care about that DIR structure. We give it to readdir in a loop, to read each directory entry. readdir function returns a pointer to direct structure or, when it's finished with directory, a null pointer. We just take the name of the file (d_name).
7. We use two functions of our handle of errors: err_sys and err_quit. The function err_sys prints an informative message describing what type of error was encountered ("Permission denied" or "Not a directory").
8. When program is done, it calls the function exit with argument of 0. Function exit terminates a program. By convention, an argument of 0 means OK, and an argument between 1 and 255 means error ocurred. This value can be retrieved from a shell in variable $?.

**Working Directory:**
every process has working directory, sometime called "current working directory". This is directory from which relative pathnames are interpreted. Process can change working directory with chdir function. Relative pathname doc/memo/joe refers to file or directory joe, in directory memo, which must be a directory within the working directory. Looking just at pathname, we know that doc and memo have to be directories, but we can't tell if joe is file or directory. Pathname /usr/lib/lint is absolute path, refers to file or directory lint in directory lib, in directory usr, which is in root.

**Home directory:**
The working directory is set to our home directory. Obtained from our entry in password file.

## Input and Output

**File Descriptors:**

normally small non-negative integers, kernel uses to identify files accessed by process, opening existing or creating a file, kernel returns file descriptor, we use when we want to read or write file.

Standard Input, Standard Output, and Standard Error:

By convention, all shells open three descriptors when program runs: standard input, standard output, and standard error. For a command like:

```console
    $ ls
```
three are connected to terminal. Shells provide a way of redirection:

```console
    $ ls > file.list
```

redirects standard output to a file named file.list.

**Unbuffered I/O:**

provided by functions open, read, write, lseek and close. These work with file descriptors.

Example: program to read from standard input and wirte to standard output. [stdin_to_stdout.c](https://github.com/K0deless/TheDoom/blob/master/code/APUE/chapter1/stdin_to_stdout.c)

Header <unistd.h> included by apue.h, and constants STDIN_FILENO and STDOUT_FILENO are part of POSIX standard. Header contains function prototypes for many UNIX system services, such as read and write functions.
Contants STDIN_FILENO and STDOUT_FILENO are in <unistd.h> and specify file descriptors for standard input and standard output, values are 0 and 1, respectively, we will use names for readability.
Section 3.9 we'll examine BUFFSIZE constant.
read function returns number of bytes that are read, value is used as number of bytes to write. When end of file is encountered, read returns 0 and program stops. If error ocurris, read returns -1 (as many system functions).
Executing file as:

```console
   $ ./stdin_to_stdout > data
```
standard input will be the terminal, and standard output is redirected to file data, and standard error is also terminal. If output file doesn't exist, shell creates it by default. Program copy bytes until we type end-of-file character (CTRL+D).
If we run:

```console
    $ ./stdin_to_stdout < infile > outfile
```

then file named infile will be copied to file named outfile.

In chapter 3 we will see unbuffered I/O more detail.

**Standard I/O:**

buffered interface to the unbuffered I/O functions. Using standard I/O relieves us from having to choose optimal buffer sizes. Standard I/O simplify dealing with lines of input (common ocurrence in UNIX applications). fgets function, reads entire line. The read function, in contrast, reads a specifed number of bytes. Standard I/O library provide functions that let us control style of buffering used by library.
Most common standard I/O function is printf. For those programs we will include <stdio.h> (included by apue.h), header contains function prototypes for all standard I/O functions.

Example: [standard_stdin_to_stdout.c](https://github.com/K0deless/TheDoom/blob/master/code/APUE/chapter1/standard_stdin_to_stdout.c) . Like previous program, program copies standard input to standard output and copy any regular file. Function getc used reads one character at a time, and character is written by putc, after last byte of input has been read, getc returns constant EOF (defined in <stdio.h>). Standard I/O constant stdin and stdout are also defined in <stdio.h> which refers to standard input and standard output.

## Programs and Processes

**Program:**
executable file residing on disk in directory. Program is read into memory and executed by kernel as result of one of seven exec functions.

**Processes and Process ID:**
executing instance of a program is called a process. Some operating system  use term task to refer a program being executed. UNIX system guarantees every process has a unique numeric identifier called process ID. Process ID is always a non-negative integer.

example: [print_pid.c](https://github.com/K0deless/TheDoom/blob/master/code/APUE/chapter1/print_pid.c) example program that prints the pid of the running process calling the function getpid, it returns a pid_t data type. We don't know size, but standards guarantee that it will fit in a long integer. We cast it to the largest data type that it might use (long integer). Although most process IDs will fit in a int, using a long promotes portability.

**Process Control:**
Three primary functions for process control: fork, exec and waitpit (exec function has seven variants, but we refer all of them as exec function).

Example: [very_simple_shell.c](https://github.com/K0deless/TheDoom/blob/master/code/APUE/chapter1/very_simple_shell.c) example of process control features demonstrated on simple program, reads commands from standard input, and executes commands. Bare-bones implementation of shell-like program.

Several features to consider in that little program. We use standard I/O fgets to read one line at a time from standard input. When we type end-of-file character (often CTRL+D) as first character of a line, fgets returns null pointer, loop stops, and process terminates. In chapter 18, we'll see all special terminal characters (end of file, backspace one character, erase entire line). Because each line returned by fgets is terminated with newline character, followed by null byte, we use standard C function strlen to calculate length of the string, then replace newline with null byte. This is done for execlp working properly. We call fork to create new process, which is a copy of caller. Caller is the parent and the newly created process is the child. fork returns: non-negative PID of new child process to parent, and 0 to the child.
In the child, we call execlp to execute command read from standard input. Replaces child process with new program file. Combination of fork + exec is called spawning a new process. In UNIX, the two parts are separated by individual functions (we'll talk more about that in Chapter 8).
Because of child process calls execlp to execute new program, parent should wait until child terminate. Done by calling waitpid, specifying which process to wait for: pid argument, which is process ID of child. waitpid returns termination status of child process (status variable), we don't do anything with that, but we could examine it to determine how child terminated.
Most fundamental limitation of program, we can't pass arguments to command we execute. We can't, specify name of a directory list. We can execute ls only in working directory. To allow arguments would require we parse input line, separating arguments as separate parameter to execlp function.

**Threads and Thread IDs:**

Usually 1 process = 1 thread, one set of machine instructions executing at a time. Some problems are easier to solve when more than one thread can operate on different parts of problem. Additionally, multiple threads of control can exploit parallelism possible on multiprocessor systems.
All threats within a process share same address space, file descriptors, stacks and process-related attributes. Each thread executes on its own stack, although any thread can access stacks of other threads. Because of access to same memory, threads need to synchronize access to shared data to avoid inconsistences.
Like processes, threads are identified by IDs. Thread IDs, however, are local to a process. A thread ID from one process has no meaning in another process. We use thread IDs to refer to specific threads as we manipulate threads within a process.
We'll see more in Chapter12 about thread parallelism and process parallelism.

## Error Handling

Error occurs in one UNIX System function, negative value often returned, integer errno, usually set to value tells why. Example, open function returns a non-negative file descritor if all is OK or -1 if error ocurrs. Error from open = about 15 possible errno values (files doesn't exist, permission problem, and so on). Some functions use a convention other than returning a negative value. Most functions that return pointer to object return null pointer to indicate error.
File <errno.h> defines symbol errno, constants for each value errno can assume. Each of the constants starts with character E. Also first page of section 2 of UNIX system manuals, named intro(2) lists all these error constants. Example if errno is equal to constant EACCES, indicates permission problem, such as insufficient permission to open requested file (On Linux, error constants are listed in errno(3)). POSIX and ISO C define errno as symbol expanding into modificable lvalue of type integer. Can be integer that contains error number or function that returns pointer to error number. Definition:     extern int errno;
In environment that supports threads, process address space is shared among multiple threads, each thread needs own local copy of errno. Linux supports multithreaded access to errno defining it as:
```C
        extern int *__errno_location(void);
        #define errno (*__errno_location())
```

Two rules to be aware of with respect to errno. First: value is never cleared by a routine if error doesn't occur. We should examine its value only when return value indicates an error ocurred. Second, value of errno is never set to 0 by any of functions, none of constants defined in <errno.h> has value of 0.

Also two functions are defined by C standard to help with printing error messages.

```C
    #include <string.h>
    char *strerror(int errnum);     // returns: pointer to message string
```

Function maps errnum, typically errno value, into an error message string and returns a pointer to string.
perror function produces error message on standard error, based on current value of errno, and returns.

```C
    #include <stdio.h>
    void perror(const char *msg);
```

outputs the string pointed to by msg, followed by a colon and a space, followed by error message corresponding to value of errno, followed by newline.

Example: [print_error.c](https://github.com/K0deless/TheDoom/blob/master/code/APUE/chapter1/print_error.c) this program we'll see the use of strerror, and perror with common error numbers. Note we pass the name of the program (argv[0], whose value is ./print_error as argument to perror. Standard convention in UNIX system, doing this, if program is executed as part of pipeline, we are able to tell which of three programs generated a particular error. Instead of calling strerror or perror, we will use the error functions from appendix B. These functions let us use variable argument list facility of ISO C to handle error conditions with single C statement.

**Error recovery:**

errors in <errno.h> can be divided into two categories: fatal and nonfatal. fatal error has no recovery. Best we can do, print error message on user's screen or to log file, then exit. Nonfatal errors, can sometimes be dealt with more robustly. Most nonfatal errors are temporary, such as resource shortage, might not occur when there's less activity on system.
Resource-related nonfatal erros: EAGAIN, ENFILE, ENOBUFS, ENOLCK, ENOSPC, EWOULDBLOCK, and sometimes ENOMEM. EBUSY can be treated as nonfatal, indicates that shared resource is in use. Sometimes, EINTR can be treated as nonfatal error when it interrupts a slow system call.
Typical error recovery action, for resource-related non fatal error, delay and retry later. Can be used for example if an error indicates, a network connection is no longer functioning, it might be for application to delay a short time, then reestablish connection. Some applications use exponential backoff algorithm, waiting longer in each subsequent iteration.
Ultimately, it is up to application developer determine cases where application can recover from an error. If reasonable recovery strategy can be used, we can improve robustness of our application by avoiding an abnormal exit.

## User Identification

**User ID:**

numeric value that identifies us to system. User ID assigned by system administrator when our login name is assigned, we cannot change it. User ID normally assigned to be unique for every user. We'll see how kernel uses user ID to check whether we have appropiate permissions to perform certain operations.
User ID with ID = 0 is root or superuser. Entry in password file normally has login name of root, we refer to special privileges of this user as superuser privileges. We'll see in Chapter 4, if process has superuser privileges, most file permission checks are bypassed. Some operating system functions are restricted to superuser. Superuser has free rein over the system.
Mac OS X comes with superuser account disabled; server versions ship with account enabled. Apple's website show how to enable it.

**Group ID:**

our entry in password file also specifies numeric group ID. This is asigned by system administrator when our login name is assigned. Typically, password file contains multiple entries that specify same group ID. Groups normally used to collect users together into projects or departments. Allows sharing of resources, such as files, among members of same group. We'll see that we can set permissions on a file so all members of a group can access file, whereas others outside group cannot.
There's group file that maps group names into numeric group IDs. Group file usually in /etc/group.
Use of numeric IDs and numeric group IDs for permissions is historical. For every file, file system stores UID and GID of file's owner. Storing both requires only four bytes, assuming each is 2-byte integer. If full ASCII login name and group name were used, additional disk space would be required. Also comparing strings during permission checks is more expensive than comparing integers.
Users work better with names than numbers, so password file maintains mapping between login names and UIDs, and group file provides mapping between group names and GIDs. ls -l command, prints login name of owner of a file, using password file to map numeric user ID into corresponding login name (early UNIX used 16-bit integer for UIDs and GIDs, current UNIX systems use 32-bit integers).

Example: [get_ids.c](https://github.com/K0deless/TheDoom/blob/master/code/APUE/chapter1/get_ids.c) program to see user ID and group ID of process owner (user which executes the program).

**Supplementary Group IDs:**

addition to GID specified in password file for login name, UNIX system allow user to belong other groups. Practice started with 4.2BSD, which allowed user to belong to up to 16 additional groups. Supplementary group IDs are obtained at login time reading the file /etc/group, and finding first 16 entries that list user as a member. As we will see in next chapter, POSIX requires system support at least 8 supplementary groups per process, but most systems support at least 16.

## Signals

technique used to notify a process some condition has occurred. If a process divides by zero, signal SIGFPE (floating-point exception) is sent to process. Process has three choices for dealing with signal.
1. Ignore signal. Option isn't recommended for signals that denote a hardware exception, such as dividing by zero or referencing memory outside the address space of the process, as the results are undefined.
2. Let default action occur. For a divide-by-zero condition, default is to terminate the process.
3. Provide a function that is called when signal occurs (this is called "catching" signal). By providing a function of our own, we'll know when signal occurs and we can handle it as we wish.

Many conditions generate signals. Two terminal keys, called interrupt key (often the DELETE key or CTRL-C) - and the quit key - often CTRL-backslash - are used to interrupt currently running process. Another way to generate a signal is calling the kill function. We can call this function from process to send a signal to another process. There are limitations: we have to be owner of the other process (or superuser) to be able to send it a signal.

Example: [sig_int_catch.c](https://github.com/K0deless/TheDoom/blob/master/code/APUE/chapter1/sig_int_catch.c) Recall bare-bones example (very_simple_shell.c). If we invoke program and press interrupt key, process terminates because default action for signal named SIGINT, is to terminate process. Process hasn't told kernel to do anything other than default with signal, so process terminates.
To catch signal, program needs to call signal function, specifying name of the function to call when SIGINT signal is generated. Function is named sig_int; when it's called, just prints a message and a new prompt. Adding 11 lines to the program in very_simple_shell.c.

## Time Values

UNIX systems have maintained two different time values:
        1. Calendar time. Value counts number of seconds since Epoch: 00:00:00 January 1, 1970, UTC. These time values are used to record time when file was last modified. Primitive system data type time_t holds these time values.
        2. Process time. Also caled CPU time, measures central processor resources used by a process. Process time is measured in clock ticks, typically 50, 60 or 100 ticks per second. The primitive data type clock_t holds these time values. We'll see how to get that function in section 2.5.4 with function sysconf.

When we measure execution time of process, as in Section 3.9, we'll see UNIX System maintains three values for process:

+ Clock time
+ User CPU time
+ System CPU time

Clock time (or wall clock time), amount of time process takes to run, value depends on number of other processes being run on system. Whenever we report clock time, measurements are made with no other activities on system.
User CPU time, is CPU time attributed to user instructions. System CPU is time attributed to kernel when it executes on behalf of the process. Example, whenever a process executes a system service (read or write), time spent within kernel performing that system service is charged to process. Sum of user CPU time and system CPU is often called CPU time.
It is easy to measure clock time, user time, and system time using the command "time(1)", with argument to time command being command we want to measure. Example:

```console
    $ time -p grep _POSIX_SOURCE */*.h > /dev/null

    real 0m0.81s
    user 0m0.11s
    sys  0m0.07s
```

Output format from time command, depends on shell being used, because some shells don't run /usr/bin/time, instead have a separate built-in function to measure time it takes commands to run.
Section 8.17, we'll see how to obtain these three times from a running process. General topic of times and dates is covered in Section 6.10.

## System Calls and Library Functions

All operating systems provide service points through which programs request services from kernel. UNIX implementations, provides limited number of entry points directly into kernel called system calls. Version 7 Research UNIX System provided 50 syscalls, 4.4BSD about 110, and SVR4 has around 120. More recent systems have seen incredible growth in number of supported syscalls. Linux 3.2.0 has 380 syscalls, and FreeBSD 8.0 over 450.
System call interface always has been documented in Section 2 of UNIX Programmer's Manual. Its definition is in C language, no matter implementation technique is used to invoke a system call. This differs from many older operating systems, which defined kernel entry point in assembly language of the machine. For our purposes, we can consider syscalls to be C functions.
Section 3 of UNIX Programmer's Manual defines general-purpose library functions available to programmers. Functions aren't entry points into kernel, although they may invoke one or more of kernel's system calls. Example, printf may use to write system call to output a string, but strcpy (copy a string) and atoi (ASCII to integer) don't involve kernel at all.

From implementor's point of view, distinction between system call and library function is fundamental. From user's perspective, difference is not as critical. From our perspective, both system calls and library functions appear as normal C functions. Both exist to provide services for application programs. We should realize, that we can replace library functions, whereas system calls usually cannot be replaced.
Consider memory allocation function "malloc". There are many ways to do memory allocation and its garbage collection. UNIX system call that handles memory allocation, sbrk, is not general-purpose memory manager. Increases or decreases address space of process by specified number of bytes. How space is managed is up to process. Memory allocation function, malloc(3), implements one particular type of allocation. If we don't like operation, we can define own malloc function, which will probably use sbrk system call. In fact, numerous software packages implement their own memory allocation algorithms with sbrk syscall.
System call in kernel allocates additional chunk of space on behalf of the process. malloc library function manages space from user level.
Another example between syscall and library function, UNIX System interface to determine current time and date. Some OSs provide one syscall to return time and another return the date. Any special handling, such as switch to or from daylight saving time, handled by kernel or requires human intervention. UNIX System, provides single syscall that returns number of seconds since Epoch: 00:00, January 1, 1970, UTC. Any interpretation of value, such as converting it to human-readable time and date using local time zone, is left to user process. Standard C library provides routines to handle most cases.
Another difference is that syscalls usually provide minimal interface, whereas library often provide more elaborate functionality. We've seen this in difference between sbrk syscall and malloc function. We'll see this also when we compare unbuffered I/O functions (Chapter 3) and standard I/O functions (Chapter 5).
Process control syscalls (fork, exec and waitpid) usually invoker by user's application code directly. But some library routines exist to simplify certain common cases: system and popen library routines. We'll show implementation of system function that invokes basic process control syscalls.
To define interface to UNIX System that most programmers use, we have to describe system calls and some of library functions. If we described only sbrk system call, we would skip more programmer-friendly malloc library that many applications use. We will use the term function to refer both syscalls and library functions, except when distinction is necessary.

# <a name="chapter2"></a> 2 - UNIX Standardization and Implementations

Mostly tables, and enumerations from POSIX's standards. There are also some type limits from POSIX and standard C and other different constants, there isn't code really so you can take a quick look to it.
Some functions listed here are: sysconf, pathconf, fpathconf.
You have also pathname limits, maximum number of open files, primitive system data types listed in header "<sys/types.h>" and finally differences between standards.

# <a name="chapter3"></a> 3 - File I/O

**Makefile for this chapter [Makefile](https://github.com/K0deless/TheDoom/blob/master/code/APUE/chapter3/Makefile)**

## Introduction

Start discussion of UNIX System describing functions available for file I/O-- open, read, write a file and so on. Most file I/O on UNIX system can be performed using five functions: open, read, write, lseek and close. We then examine effect of various buffer sizes on read and write functions.
Functions described in chapter are often referred to as unbuffered I/O, in contrast to standard I/O routines, which we describe in Chapter 5. Term unbuffered means each read or write invokes syscall in kernel. Unbuffered I/O functions are not part of ISO C, are part of POSIX.1 and Single UNIX Specification.
Whenever we describe sharing of resources among multiple processes, concept of atomic operation becomes important. We examine concept with regard to file I/O and arguments to open function. This leads to discussion of how files are shared among multiple processes and which kernel data structures are involved. After describing features, we describe dup, fcntl, sync, fsync and ioctl functions.

## File Descriptors

To kernel, all open files are file descriptors. File descriptor is non-negative integer. When open existing file or create new one, kernel returns file descriptor to process. When we want to read or write a file, we identify file with file descritor returned by open or creat, as argument to read or write.
By convention, UNIX shells associate file descriptor 0 as standard input, 1 as standard output, and 2 as standard error of process. Convention used by shells and many applications; not feature of UNIX kernel. Many application would break if associations weren't followed.
Values are standardized by POSIX.1, but magic numbers (0,1 and 2) should by replaced in POSIX-compliant apps to symbolic constants STDIN_FILENO, STDOUT_FILENO, and STDERR_FILENO to improve readability, constants defined in *<unstid.h>* header.
File descriptors goes from 0 to OPEN_MAX - 1. Early historical implementations of UNIX had opper limit of 19, allowing maximum of 20 open file per process, may systems increases limit to 63.

## open and openat Functions

File created or opened using any of these functions:

```C
    int open (const char *path, int oflag, ... /* mode_t mode */ );
    int openat (int fd, const char *path, int oflag, ... /* mode_t mode */ );

    Both return: file descriptor if OK, -1 on error.
```

We show last argument as ..., ISO C way to specify number and types of remaining arguments may vary. For these functions, last argument used only when new file is being created. We show argument as comment in prototype.
path parameter is name of file to open or create. Function has multitude of options, specified by oflag argument. Argument is formed by ORing together one or more of following constants from *<fcntl.h>* header:

* O_RDONLY: open for reading only
* O_WRONLY: open for writing only
* O_RDWR: open for reading and writing
* O_EXEC: open for execute only
* O_SEARCH: open for search only (for directories) this one is used to evaluate search permission at time a directory is opened, further operations using directory's file descriptor will not reevaluate permission to search.

One and only one of previous five constants must be specified, next will be optional:

* O_APPEND: append to end of file on each write.
* O_CLOEXEC: set FD_CLOEXEC file descriptor flag.
* O_CREATE: Create file if it doesn't exist, option requires third argument to open function, mode, which specifies access permission bits of new file. We'll see how it can be modified by umask value of process.
* O_DIRECTORY: Generate error if path doesn't refer to directory
* O_EXCL: Generate error if O_CREAT also specified file and file exists. This test if file already exists and creation of file if it doesn't exist is an atomic operations. We'll see.
* O_NOCTTY: If path refers to terminal device, don't allocate device as controlling terminal for this process. We'll see in chapter 9.
* O_NOFOLLOW: Generate error if path refers to symbolic link.
* O_NONBLOCK: If path refers to FIFO, a block special file, or character special file, this option sets nonblocking mode for both opening of file and subsequent I/O.
    
*(In releases of System V, O_NDELAY (no delay) flag was introduced. SImilar to O_NONBLOCK option, but ambiguity was introduced in return value from read operation. no-delay causes a read operation return 0 if no data to be read from pipe, FIFO or device, but conflicts with return value of 0, indicating end of file. SVR4-based system still support no-delay, but nw apps should use nonblocking option instead)*
    
* O_SYNC: Make each write wait for physical I/O to complete, including I/O necessary update file attributes modified as result of write.
* O_TRUNCT: If file exists and if opened for either write-only or read-write, truncate length to 0.
* O_TTY_INIT: When opening terminal device not already open, set nonstandard termios parameters to values that result in behavior that conforms Single UNIX Specification. We'll see in chapter 18.


Following two flags are also optional. They are part of synchronized input and output options of Single UNIX Specification.

* O_DSYNC: Make each write wait for physical I/O to complete, but don't wait for file attributes to be updated if they don't affect ability to read data just written. In O_DSYNC affects a file's attributes only when they need to be updated to reflect change in file's data. With O_SYNC flag, data and attributes are always updated synchrnously.
* O_RSYNC: Make each read operation on file descriptor wait until any pending writes for same portion of file are complete.

File descriptor returned by open and openat guaranteed to be lowest-numbered unused descriptor. This fact used by some applications to open new file on standard input, standard output, or standard error. Example, application might close standard output (normally, file descriptor 1) then open another knowing that it will be opened on file descriptor 1. We'll see better way to guarantee that file is open on given descriptor, with the function "dup2" (better than "dup").

*fd* parameter distinguishes openat function from open function. There are three possibilities:

1. path parameter specifies an absolute pathname. This case, fd parameter is ignored and openat functions behaves like open function.
2. path parameters specified relative pathname and fd parameter is file descriptor that specifies starting location in file system where relative pathname is to be evaluated. fd parameter obtained by opening the directory where relative pathname is to be evaluated.
3. path parameter specified a relative pathname and fd parameter has special value AT_FDCWD. This case, pathname is evaluated starting in current working directory and openat function behaves like open function.

*openat* function is one of a class of functions added to latest version of POSIX.1 to address two problems. First, gives threads way to use relative pathnames to open files in directories other than current working directory. All threads share same current working directory, so makes it difficult for multiple threads in same process to work in different directories at same time. Second, it provides a way to avoid time-of-check-to-time-of-use (*TOCTTOU*) errors.

*TOCTTOU* errors program vulnerable if it makes two file-based function calls where second call depends on result of first call. Because two calls are not atomic, file can change between the two calls, thereby invalidating results of first call, leading to a program error. TOCTTOU errors in file system namespace generally deal with attempts to subvert file system permissions by tricking privileged program into either reducing permissions on privileged file or or modifying a privileged file to open up a security hole. Wei and Pu [2005] talk about TOCTTOU in UNIX file system.

**Filename and Pathname Truncation**

What happens if NAME_MAX is 14 and we try to create new file in current directoy with filename containing 15 characters? Traditionally, early releases of System V, allowed this to happen, silently truncating filename beyond the 14th character. BSD-derived systems, returned error status, with errno set to ENAMETOOLONG. Silently truncating filename presents a problem that affects more than simply creation of new files. If NAME_MAX is 14 and file exists whose name is exactly 14 characters, any function that accepts pathname argument, such as open or stat, has no way to determine what original name of file was, as original name might have been truncated.

POSIX.1, constant \_POSIX\_NO\_TRUNC determines whether long filenames and long components of pathnames are truncated or an error is returned. Value can vary based on type of file system, we can use fpathconf or pathconf to query a directory to see which behaviour is supported.

If \_POSIX\_NO\_TRUNC is in effect, errno is set to ENAMETOOLONG, and error status is returned if any filename component of pathname exceeds NAME_MAX. (Most modern file systems support maximum of 255 characters, so usually is not a problem).

## creat Function

New file can be created calling "creat" function:

```C
    #include <fcntl.h>
    int creat (const char *path, mode_t mode);
        Returns: file descriptor opened for write-only if OK, -1 on error.
```

This function is equivalent to:

```C
    open(path, O_WRONLY | O_CREAT | O_TRUNC, mode);
    
```
As historically open only accepted 0, 1 or 2 as second argument, and it wasn't possible to open a non-existing file, creat was used. With O_CREAT and O_TRUNC provided by open, separate creat function no longer needed.


We'll see later the mode, when we describe file's access permission in detail. One deficiency with creat, file is opened only for writing. Before new version of open was provided, if we were creating temp file that we wanted to write and read, we had to call "creat", "close" and then "open". Better way is to use "open" function in this way:

```C
    open(path, O_RDWR | O_CREAT | O_TRUNC, mode);
```

## close Function

Open file is closed calling "close" function:

```C
    #include <unistd.h>
    int close (int fd);
        Returns 0 if OK, -1 on error
```

Closing a file, release any record locks that process may have on file. We'll discuss that further later.
When a process terminates, all of its open files are closed automatically by kernel. Many programs take advantage of this fact and don't explicitly close open files.

## lseek Function

Every open file has associated a "current file offset", a non-negative integer that measures number of bytes from the beginning of file (We'll see some exceptions to "non-negative" qualifier). Read and write operations normally start at current file offset and cause offset to be incremented by number of bytes read or written. By default, offset is 0 when file is opened, unless O_APPEND option is specified.
Open file's offset can be set calling "lseek":

```C
    #include <unistd.h>
    off_t lseek (int fd, off_t offset, int whence);
        Returns: new file offset if OK, -1 on error
```

Interpretation of offset depends on value of whence argument:

- if whence is SEEK_SET, file's offset is set to offset bytes from the beginning of the file.
- if whence is SEEK_CUR, file's offset is set to current value plus offset. Offset can be positive or negative.
- if whence is SEEK_END, file's offset is set to size of file plus offset. Offset can be positive or negative.

Because successful call to lseek returns new file offset, we can seek zero bytes from current position to determine current offset:

```C
    off_t   currpos;
    currpos = lseek(fd, 0, SEEK_CUR);
```

Technique can be used to determine if file is capable of seeking. If file descriptor refers to a pipe, FIFO, or socket, lseek sets errno to ESPIPE. (Three constants SEEK_SET, SEEK_CUR and SEEK_END were introduced in System V. Prior to this whence was 0 (absolute), 1 (relative to current offset), or 2 (relative to end of file). Character l in lseek means "long integer". Before introduction of off_t data type, offset argument and return value were long integers. lseek was added with Version 7 when long integers were added to C (previous to that the functions seek and tell were used)).

Example: [test_lseek.c](https://github.com/K0deless/k0deless.github.io/blob/master/code/APUE/chapter3/test_lseek.c) to see whether the standard input is capable of seeking. Here we can call the program giving different ways of input:

```console
    $ ./test_lseek < /etc/passwd # input is a file (seek OK)
    $ cat < /etc/passwd | ./test_lseek # input here is an string (cannot seek)
    $ ./test_lseek < /var/spool/cron/FIFO # input here is a FIFO (cannot seek)
```

A file's current offset must be a non-negative integer. It is possible, certain devices could allow negative offsets. But regular files, offset must be non-negative. Because negative offsets are possible, we should compare return of lseek with -1, and not if is lower than 0.

*lseek* only records current file offset within kernel, it does not cause any I/O to take place. This offset then sued by next read or write operation.

File's offset can be greater than file's current size, in which case next write to file will extend the file. This is referred to as creating a hole in a file and is allowed. Any bytes in a file that have not been written are read back as 0.

A hole in a file isn't required to have storage backing it on disk. Depending on file system implementation, when you write after seeking past end of a file, new disk blocks might be allocated to store the data, but there's no need to allocate disk blocks for data between old end of file and location where you start writing.

Example: [file_hole.c](https://github.com/K0deless/k0deless.github.io/blob/master/code/APUE/chapter3/file_hole.c) example that creates a file with a hole in it. We can see with "ls -l file.hole" the size of the file, and then with "od -c file.hole" the content of the file. The flag -c of "od" command tells to print the contents as characters. Unwritten bytes in the middle are read back as zero. The seven-digit number at the beginning of each line is the byte offset in octal.

Because offset address that lseek uses is an off_t, implementations are allowed to support whatever size is appropiate on their particular platform. Most platforms today provide two sets of interfaces to manipulate file offsets: one that uses 32-bit file offsets and another that uses 64-bit file offsets.

Single UNIX specification provides a way for applications to determine which environments are supported through sysconf function. Figure 3.3 in page 70, gives a set of Name of option and description of types depending on the system.
c99 compiler requires that we use getconf(1) command to map desired data size model to flags necessary to compile and link our programs. Different flags and libraries might be needed, depending on environments supported by each platform.
Applications can set \_FILE\_OFFSET\_BITS constant to 64 to enable 64-bit offsets. Doing so changes definition of off_t to be 64-bit signed integer. Setting \_FILE\_OFFSET\_BITS to 32 enables 32-bit file offsets. This technique is not guaranteed to be portable.

Different versions as Figure 3.4 of page 70 shows, can have different values if \_FILE\_OFFSET\_BITS is set or not.
Even though you might enable 64-bit file offsets, ability to create a file larger than 2GB (2^31 -1 bytes) depends on underlying file system type.


## read Function

Data read from open file with read function

```C
    #include <unistd.h>
    ssize_t read(int fd, void *buf, size_t nbytes);
        Returns: number of bytes read, 0 if end of file, -1 on error
```

If read is successful, number of bytes read is returned. If end of file is encountered, 0 is returned.
Several cases in which number of bytes actually read is less than aument requested:

* When reading from regular file, if end of file is reached before requested number of bytes has been read. Example, 30 bytes remain until end of file and we try to read 100 bytes, read returns 30. Next time will return 0.
* Reading from a terminal device. Normally, one line is read at a time.
* When reading from network. Buffering within network may cause less than requested amount to be returned.
* When reading from a pipe or FIFO. If pipe contains fewer bytes than requested, read will return only what is available.
* When reading from record-oriented device. Some of them such as magnetic tape, can return up to single record at a time.
* Interrupted by a signal and partiaul amount of data has already been read.

Read operation starts at file's current offset. Before successful return, offset is incremented by number of bytes actually read.
POSIX.1 changed prototype for function in several ways, classic definition:

```C
    int read (int fd, char *buf, unsigned nbytes);
```

* Second argument changed from char \* to void \*, to be consistent with ISO C: type void \* is used for generic pointers.
* Return value was required to be signed integer (ssize_t) to return positive byte count, 0 (end of file), or -1 (for error)
* Finally historically third argument was unsigned integer, to allow 16-bit implementation to read or write up to 65,534 bytes at a time. With 1990 POSIX.1, primitive system data type ssize_t was introduced, to provide signed return value, and unsigned size_t was used for third argument.

## write Function

Data written to open file with write function:

```C
    #include <unistd.h>
    ssize_t write (int fd, const void *buf, size_t nbytes);
        Returns: number of bytes written if OK, -1 on error
```

Return value usally equal to nbytes argument; otherwise error has occurred. Common cause for write error is filling up a disk or exceeding file size limit for given process.

For regular file, write operation starts at file's current offset. If O_APPEND option was specified, file's offset is set to current end of file before each write operation. After successful write, file's offset is incremented by number of bytes actually written.

## I/O Efficiency

Example: [copy_file.c](https://github.com/K0deless/k0deless.github.io/blob/master/code/APUE/chapter3/copy_file.c), uses only read and write functions. Following caveats apply to the program:

* Reads from standard input and writes to standard output assuming these have been set up by shell before program is executed. Indeed, all normal UNIX system shells provide way to open file for reading on standard input and to create (or rewrite) file on standard output. Prevents program from having to open input and output files, and allows user to take advantage of shell's I/O redirection facilities.
* Program doesn't close input file or output file. Program uses feature of UNIX kernel that closes all open file descriptors in process when process terminates.
* Example works for both text files and binary files, since there's no difference between both to UNIX kernel.

Some tests were done with BUFFSIZE, program was run with different values of BUFFSIZE to check the User CPU (in seconds), System CPU (in seconds), clock time (in seconds) and number of loops.

File was read using previous program, with output redirected to /dev/null. File system used was a Linux with ext4 file system with 4,096 blocks. This makes that minimum time ocurring at the few timing measurements starting around a BUFFSIZE of 4,096. Increasing buffer size beyond limit has little positive effect.

Most file systems support read-ahead to improve performance. When sequential reads are detected, system tries to read-ahead than application request, assuming application will read it shortly. Effect of read-ahead can be seen in timing tables, where with a small buffer of 32 bytes system start to improve times because of read-ahead.
We'll see the effect of synchronous writes; later we will compare unbuffered I/O times with standard I/O library.

## File Sharing

UNIX System supports sharing of open files among different processes. Before describing dup function, we need to describe this sharing. We'll examine data structures used by kernel for all I/O.
The kernel uses three data structures to represent an open file, and relationship among them determine effect one process has on another with regard to file sharing.

1. Every process has entry in process table. Within each process table entry is a table of open file descriptors, which we can think of as a vector, with one entry per descriptor. Associated with each file descriptor are:
    * file descriptor flags (close-on-exec)
    * pointer to a file table entry
2. Kernel maintains file table for all open files. Each file table entry contains:
    * file status flags for file, such as read, write, append, sync, and nonblocking.
    * current file offset.
    * pointer to v-node table entry for the file
3. Each open file (or device) has v-node structure that contains information about type of file and pointers to functions that operate on the file. For most files, v-node also contains i-node for the file. Information is read from disk when file is opened, so all the pertinent information about file is readily available. Example, i-node contains owner of the file, size of the file, pointers to where actual data blocks for file are located on disk. (Linux has no v-node. Instead, generic i-node structure is used. Although implementations differ, v-node is conceptually the same as generic i-node. Both point to an i-node structure specific to file system).
We're ignoring implementation details don't affect our discussion. Example, table of open file descriptors can be stored in user area (a separate process structure that can be paged out) instead of process table. Also, these tables can be implemented in numerous ways, do not need to be arrays; another alternate implementation is a linked list of structures. Concepts remain the same.

Figure 3.7 of page 75 shows pictorial arrangement of these three tables for single process that has two different files open: one file is open on standard input (file descriptor 0), and other is open on standard output (file descriptor 1).

<img src="https://notes.shichao.io/apue/figure_3.7.png">

Arrangement of three tables has existed since early versions of UNIX system. Arrangement is critical to the way files are shared among processes. We'll return to table when we describwe additional ways that files are shared.

(v-node was invented to provide support for multiple file system types on single computer system. This was done by Peter Weinberger and Bill Joy. Sun called this Virtual File System and called the file system-independent portion of the i-node the v-node. v-node propagated through various vendor implementations as support for Sun's Network File System (NFS) was added. First release from Berkeley to provide v-node was 4.3BSD Reno release, when NFS was added. In SVR4, v-node replaced file system-independent i-node of SVR3. Solaris is derived from SVR4 and uses v-nodes. Instead of splitting data structures into v-node and i-node, Linux uses file system-independent i-node and a file system-dependent i-node.)

If two independent process have same file open, we could have as Figure 3.8 in page 76, where each process table entry (in user process) points to a different file table entry (in kernel) but finally each v-node pointer points to same v-node table entry and this to same i-node.

<img src="https://notes.shichao.io/apue/figure_3.8.png">

In example we see that first process has file open on descriptor 3, and other process in descriptor 4. So as we said each process has its own file table entry, but only single v-node is required. One reason why each process has its own file table entry is because each process has its own current file offset for file.
Given these data structures, now need to be more specific about what happens with certain operations that we've described.

* After write is complete, current file offset in file table entry is incremented by number of bytes written. If causes current file offset to exceed current file size, current file size in i-node table entry is set to current file offset (file is extended).
* If file is opened with O_APPEND flag, corresponding flag is set in file status flags of file table entry. Each time a write is performed for a file with this flag set, current file offset in file table entry is first set to current file size from i-node table entry. Forces every write to be appended to current end of file. (IMPORTANT FOR LATER)
* If file is positioned to current end of file using lseek, all that happens is current file offset in file table entry is set to current file size from i-node table entry. (Not the same that using flag O_APPEND)
* lseek function modifies only current file offset in file table entry. No I/O takes place.

It's possible for more than one file descriptor entry, point to same file table entry, as we'll see with "dup" function. This also happens after a "fork" when parent and child share same file table entry for each open descriptor.

Note difference in scope between file descriptor flags and file status flags. Former apply only to single descriptor in single process, whereas latter apply to all descriptors in any process that point to given file table entry. When we describe fcntl function in Section 3.14, we'll see how to fetch and modify both, file descriptor flags and file status flags.

Everything described in this section works fine for multiple processes that are reading same file. Each process has its own file table table entry with its own current file offset. Unexpected results can arise, when multiple processes write to same file. We need to understand concept of atomic operations.

## Atomic Operations

Appending to a File: consider single process that wants to append to end of a file. Older versions of UNIX System didn't support O_APPEND option, so program was like this:

```C
    if (lseek (fd, 0L, 2) < 0)  /* position to EOF */
        err_sys("lseek error");
    if (write (fd, buf, 100) != 100)    /* and write */
        err_sys("write error");
```

Works fine for single process, but there are problems if multiple process use this technique to append to same file (example multiple instances of same program are appending messages to log file).

Assume two independent processes, A and B, are appending to same file. Each has opened the file but without O_APPEND flag. This gives us same picture as Figure 3.8. Each process has its own file table entry, but they share a single v-node table entry. Assume process A does lseek and sets current offset for file for process A to byte offset 1,500 (current end of file). Then kernel switches processes, and B continues running. Process B then does lseek, which sets current does lseek, which sets current offset for file for process B to byte offset 1,500 also (current end of file). Then B calls write, which increments B's current file offset for file to 1,600. Because file's size has been extended, kernel also updates current file size in v-node to 1,600. Then kernel switches processes and A resumes. When A calls write, data is written starting at current file offset for A, which is byte offset 1,500. This overwrites data that B wrote to the file (because without O_APPEND current file offset is not updated to i-node current file size).

Problem, is that logical operation of "position to the end of file and write" requires two separate function calls. Solution is to have positioning to current end of file and write be an atomic operation with regard to other processes. Any operation that requries more than one function call cannot be atomic, as kernel might temporarily suspend process between two function calls.

The UNIX System provides atomic way to do this operation if we set the O_APPEND flag when file is opened. This causes kernel to position the file to its current end of file before each write. We no longer have to call lseek before each write.

**pread and pwrite Functions**

UNIX specification includes two functions, allow applications to seek and perform I/O atomically: pread and pwrite.

```C
    #include <unistd.h>

    ssize_t pread(int fd, void *buf, size_t nbytes, off_t offset);
        Returns: number of bytes read, 0 if end of file, -1 on error

    ssize_t pwrite(int fd, void *buf, size_t nbytes, off_t offset);
        Returns: number of bytes written if OK, -1 on error.
```

Calling pread = calling lseek + read, with exceptions:
* There's no way to interrupt two operations that occur when we call pread.
* Current file offset is not uploaded.

Calling pwrite = calling lseek + write with similar exceptions.

(Really this is because, function instead of using the "current file offset" from "file table entry" they tell to the operating system: "hey OS, could you be so kind to the specified offset on disk and write or read? So it does not imply the current file offset" Thanks to jalopezg from UC3M-ARCOS for explanation of table and functions).

**Creating a File**

We saw another atomic operation when we described O_CREAT and O_EXCL options for open. When both exist, open will fail if file already exists. We said check for existence of file, and creation of file was performed as atomic operation. Without that atomic operation we had to do:

```C
    if (( fd = open(path, O_WRONLY) ) < 0) {
        if (errno == ENOENT) {
            if (( fd = creat(path, mode)) < 0 )
                err_sys("creat error");
        } else {
            err_sys("open error");
        }
    }
```

But there's a problem if a process create the file between open and creat calls. If that happens and the other process writes something, content will be erased with creat function. For that reason combining test for existence and creation into single atomic operation avoids problem.

Atomic operation refers to operation that might be composed of multiple steps. If operation is atomic, all the steps are performed (success) or none are performed (failure). We'll again see atomic operations with the function link.

## dup and dup2 Functions

Existing file descriptor is duplicated with this functions:

```C
    #include <unistd.h>

    int dup (int fd);
    int dup2 (int fd, int fd2);
        Both return: new file descriptor if OK, -1 on error
```

New file descriptor returned by dup, guaranteed to be lowest-numbered available file descriptor. With dup2, we specify the new descriptor with fd2 argument (example we can specify a socket as first argument, and stdin, stdout and stderr as second argument). If fd2 is open, it's first closed. If fd == fd2, dup2 returns fd2 without closing it. Otherwise, FD_CLOEXEC file descriptor flag, cleared for fd2, so fd2 is left open if process calls exec.

New file descriptor returned as value of functions shares same file table entry (the one from kernel) as fd argument.
<img src="https://notes.shichao.io/apue/figure_3.9.png">

In Figure 3.9 (page 80), we assume that at beginning of program executes:

```C
    newfd = dup(1);
```

So probably, if no file was opened, next available descriptor is 3 (0, 1 and 2 are opened by the shell). And as both point same file table entry, share file status flags, current file offset and v-node pointer. The descriptor flag close-on-exec is cleared by dup functions always.

fcntl function can be used to duplicate dup and dup2:

```C
    dup(fd)         =   fcntl(fd, F_DUPFD, 0)

    dup2(fd, fd2)   =   close(fd2)
                        fcntl(fd, F_DUPFD, fd2)
```

This last one is not the same, because dup2, is atomic, but close followed by fcntl isn't. This can be a proble if there's a signal between both or there's a different thread.

Also there are some errno differences between dup2 and fcntl.

## sync, fsync, and fdatasync Functions

Implementations of UNIX System have buffer cache or page cache in kernel through which most disk I/O passes. When we write data to a file, data is normally copied by kernel into one of its buffer and queued for writing to disk at some later time. This is "delayed write".
Kernel eventually writes all delayed-write blocks to disk, normally when it needs to reuse buffer for some other disk block. The explained three functions are used to ensure consistency of file system on disk with contents of buffer cache.

```C
    #include <unistd.h>

    int fsync(int fd);
    int fdatasync(int fd);
        Returns: 0 if OK, -1 on error
    void sync(void);
```

sync function simply queues all modified block buffers for writing and returns; it does not wait for disk writes to take place.

Function sync called periodically ( \~30 seconds ) from system daemon (called update). This guarantees regular flushing of kernel's block buffers. Command sync also calls sync function.

Function fsync refers only to single file, specified by file descriptor fd, waits for disk writes to complete before returning. Function is used when application, such as database, needs to be sure, modified blocks have been written to disk.

The fdatasync function similar to fsync, but it affects only data portions of a file. With fsync, file's attributes are also updated synchronously.

## fcntl Function

it can change properties of a file that is already open.

```C
    #include <fcntl.h>
    int fcntl(int fd, int cmd, ... /* int arg */ );
        Return: depends on cmd if OK, -1 on error
```

In examples, third argument is always an integer. When we describe record locking in section 14.3, third argument will become a pointer to a structure. fcntl function used for five different purposes:

* Duplicate existing descriptor (cmd = F_DUPFD or F_DUPFD_CLOEXEC)
* Get/set file descriptors flags (cmd = F_GETFD or F_SETFD)
* Get/set file status flags (cmd = F_GETFL or F_SETFL)
* Get/set asynchronous I/O ownership (cmd = F_GETOWN or F_SETOWN)
* Get/set record locks (cmd = F_GETLK, F_SETLK or F_SETLKW)

Let's describe the first 8 of 11 cmd values.

* *F_DUPFD*: duplicate file descriptor fd. New file descriptor returned as value of the function. It is lowest-numbered descriptor not already open, and is greater than or equal to the third argument (an integer), new filedescriptor share same file table entry as fd. New descriptor has its own set of file descriptor flags, and its FD_CLOEXEC file descriptor flag is cleared (descriptor is lef open across an exec).
* *F_DUPFD_CLOEXEC*: Same as before, but this time set the FD_CLOEXEC file descriptor flag in new descriptor.
* *F_GETFD*: return file descriptor flags for fd as value of function. Currently, only one file descriptor flag is defined FD_CLOEXEC flag.
* *F_SETFD*: Set file descriptor flags for fd. New flag value is set from third argument.
* *F_GETFL*: Return file status flags for fd as value of the function. We described file status flags when described open, here is a sumary:
    * *O_RDONLY*: open only for reading
    * *O_WRONLY*: open only for writing
    * *O_RDWR*: open for reading-writing
    * *O_EXEC*: open for execute only
    * *O_SEARCH*: open directory for searching only
    * *O_APPEND*: append on each write
    * *O_NONBLOCK*: nonblocking mode
    * *O_SYNC*: wait for writes to complete (data and attributes.
    * *O_DSYNC*: wait for writes to complete (data only)
    * *O_RSYNC*: synchronize reads and writes
    * *O_FSYNC*: wait for writes to complete (FreeBSD and MacOSX)
    * *O_ASYNC*: asynchronous I/O.

    *Problem that the first 5 are not separate bits that can be tested (example the first 3 have the values 0,1, and 2 for historical reasons. Also, these five values are mutually exclusive). We must first use O_ACCMODE mask to obtain the access-mode bits and then compare result against any of five values.*

* *F_SETFL*: set file status flags to value of third argument. The only flags that can be changed are O_APPEND, O_NONBLOCK, O_SYNC, O_DSYNC, O_RSYNC, O_FSYNC and O_ASYNC.
* *F_GETOWN*: Get process ID or process group ID currently receiving SIGIO and SIGURG signals. We'll see in chapter 14.
* *F_SETOWN*: Set process ID or process group ID to receive SIGIO and SIGURG signals. Positive arg specifies a process ID. A negative arg implies a process group ID equal to absolute value of arg.

Return value from fcntl depends on command. All commands return -1 on error or some other value if OK. Following four: F_DUPFD, F_GETFD, F_GETFL, and F_GETOWN. First returns new file descriptor, next two return corresponding flags, and final returns positive process ID or negative process group ID.

Example: [check_file_descriptor_flags.c](https://github.com/K0deless/k0deless.github.io/blob/master/code/APUE/chapter3/check_file_descriptor_flags.c) example program where we use fcntl to check the file flags of the file descriptors. Let's see the checks:

```console
    $ ./program 0 < /dev/tty # opens /dev/tty as stdin
    read only
    $ ./program 1 > temp.foo # opens temp.foo as stdout
    $ cat temp.foo
    write only
    $ ./program 2 2>>temp.foo # opens temp.foo as stderr appending data
    write only, append
    $ ./program 5 5<>temp.foo
    read write
```

The clause 5<>temp.foo opens file temp.foo for reading and writing on descriptor 5.

Example: If we modify file descriptor flags or file status flags, we must fetch existing flag value, modify it as desired, and set new flag value. We can't simply issue F_SETFD or F_SETFL command. Next is a function to set one or more of file status flags for a descriptor.

```C
    #include "apue.h"
    #include <fcntl.h>

    void
    set_fl (int fd, int flags) /* flags are file status flags to turn on */
    {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
            err_sys("fcntl F_GETFL error");

        val |= flags;   /* turn on flags */

        if (fcntl(fd, F_SETFL, val) < 0)
            err_sys("fcntl F_SETFL error");
    }
```

But if we change middle statement to:

```C
    #include "apue.h"
    #include <fcntl.h>

    void
    clr_fl (int fd, int flags)
    {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
            err_sys("fcntl F_GETFL error");

        val &= ~flags;      /* turn flags off */

        if (fcntl(fd, F_SETFL, val) < 0)
            err_sys("fcntl F_SETFL error");
    }
```

Using the AND operation, and the complement of flags, we can reset the previous values of val.

Adding line:

```C
    set_fl(STDOUT_FILENO, O_SYNC);
```

to the beginning of program shown in Figure 3.5, we'll turn on synchrnous-write flag. So this would make each write to wait for the data to be written to disk before returning. As UNIX System, write only queues data for writing; actual disk write can take place sometime later. Database system, likely candidate for using O_SYNC, so that it knows on return from a write that data is actually on disk, in case of abnormal system failure.

O_SYNC flag increase system and clock times when program runs.

## ioctl Function

The alfa and the omega of I/O operations. So anything that couldn't be expressed using one of the other functions in this chapter usually ended up being specified with an ioctl. Terminal I/O was biggest user of this function (We'll see in chapter18, that many of this operations has been replaced with separated functions).

```C
    #include <unistd.h>     /* System V */
    #include <sys/ioctl.h>      /* BSD and Linux */

    int ioctl(int fd, int request, ... );
        Returns: -1 on error, something else if OK

```

ioctl was included in Single UNIX Specification only as extension for dealing with STREAMS devices, but it was moved to obsolescent status in SUSv4. UNIX System implementations use ioctl for many miscellaneous device operations.


Showed property corresponds to POSIX.1. FreeBSD 8.0 and Mac OS X 10.6.8, declare second argument as unsigned long. This doesn't matter, since second argument is always a #defined name from a header.

For ISO C prototype, an ellipsis is used for remaining arguments. Normally, however, there is only one more argument, usually a pointer to a variable or a structure.

In this prototype, we show only headers required for function itself. Normally, additional device-specific headers are required. Example, ioctl commands for terminal I/O, beyond basic operations specified by POSIX.1, all require *<termios.h>* (instead of *<sys/termios.h>* that is deprecated).

Each, device driver can define its own set of ioctl commands. System however, provides generic ioctl commands for different classes of devices. Here example of ioctls, with category, constant names, header and number:

```
    disk labels         DIOxxx      <sys/disklabel.h>   4
    file I/O            FIOxxx      <sys/filio.h>       14
    mag tape I/O        MTIOxxx     <sys/mtio.h>        11
    socket I/O          SIOxxx      <sys/sockio.h>      73
    terminal I/O        TIOxxx      <sys/ttycom.h>      43
```

The mag tape operations allow us to write end-of-file marks on a tape, rewind a tape, space forward... None of these operations is easily expressed in terms of other functions (like read, write, lseek, etc), so easiest way to handle these has always been to access their operations using ioctl.
We use ioctl in chapter 18 to fetch and set size of terminal's window, and in chapter 19 when we access advanced features of pseudo terminals.

## /dev/fd

Newer systems provide directory named /dev/fd, whose entries are files named 0, 1, 2 and so on. Opening file /dev/fd/n is equivalent to duplicating descriptor n, assuming that descriptor n is open.
Example:

```C
    fd = open("/dev/fd/0", mode);
```

most systems ignore specified mode, whereas others require that it be a subset of mode used when referenced file (stdin in this case) was originally opened.
Because previous open is equivalent to:

```C
    fd = dup(0);
```

descriptors 0 and fd share same file table entry. If descriptor 0 was opened read-only, we can only read on fd. Even if system ignores open mode and the call:

```C
    fd = open("/dev/fd/0", O_RDWR);
```

succeeds, we still can't write to fd. (Linux when you open /dev/fd/0 what it does is to map a symbolic link to underlying physical files).

We can also call creat, as well as specify O_CREAT in a call to open. Beware of doing this on Linux, as it uses symbolic links to real files, using creat will result in underlying file being truncated.

Other systems provide pathnames /dev/stdin, /dev/stdout and /dev/stderr. Equivalent to /dev/fd/0, /dev/fd/1 and /dev/fd/2.

Main use of /dev/fd files is from shell. Allows that use pathname arguments to handle standard input and standard output in same manner as other pathnames. Example, cat program looks for an input filename of - and uses it to mean standard input:

```console
    $ filter file2 | cat file1 - file3 | lpr
```

First cat reads file1, then its standard input (output of filter program on file2), and then file3. If /dev/fd is supported, special handling of - can be replaced by:

```console
    $ filter file2 | cat file1 /dev/fd/0 file3 | lpr
```


# <a name="chapter4"></a> 4 - Files and Directories

**Makefile for this chapter [Makefile](https://github.com/K0deless/k0deless.github.io/blob/master/code/APUE/chapter4/Makefile)**

Previous chapter was related to manage files through I/O functions for regular files (opening file, read it, writing). Now we will look to features of file system and properties of a file. We'll start with stat functions, and go through each m<F2>ember of the stat structure, looking the attributes. Then we'll describe each of functions that modify these attributes: change owner, change permissions, and so on. We'll also look at the structure of a UNIX file system and symbolic links. Finally we will talk about functions that operate on directories, and we develop a function that descends through a directory hierarchy.

## stat, fstat, fstatat and lstat Functions

discussion in this chapter centers on four stat functions and information they return:

```C
    #include <sys/stat.h>

    int stat(const char *restrict pathname, struct stat *restrict buf);
    int fstat(int fd, struct stat *buf);
    int lstat(const char *restrict pathname, struct stat *restrict buf);
    int fstatat(int fd, const char *restrict pathname, struct stat *restrict buf, int flag);
        
        All four return: 0 if OK, -1 on error
```

Given pathname, *stat* function returns structure of information about named file. fstat function obtains information about file that is already opened on file descriptor *fd* (better to avoid TOCTTOU vulnerabilities). lstat function similar to stat, but when named file is symbolic link, lstat returns information about symbolic link, not file referenced by symbolic link.

*fstat* function provides a way to return file statistics for a pathname relative to open directory represented by fd argument. flag argument controls whether symbolic links are followed; when AT_SYMLINK_NOFOLLOW flag is set, fstatat will not folllow symbolic links, rather returns information about the link itself. Otherwise, default is to follow symbolic links, returning information about the file to which symbolic link points. If fd argument has value AT_FDCWD and pathname argument is relative pathname, then fstatat evaluates pathname argument relative to "current working directory". If pathname is absolute pathname, then fd argument is ignored. These two cases, fstatat behaves like wither *stat* or *lstat*, depending on value of flag.

buf argument is a pointer to a structure that we must supply. Functions fill in structure. Definition of the structure can differ among implementations but looks like:

```C
    struct stat {
        mode_t      st_mode;    /* file type & mode (permissions) */
        ino_t       st_ino;     /* i-node number (serial number) */
        dev_t       st_dev;     /* device number  (file system) */
        dev_t       st_rdev;    /* device number for special files */
        nlink_t     st_nlink;   /* number of links */
        uid_t       st_uid;     /* user ID of owner */
        gid_t       st_gid;     /* group ID of owner */
        off_t       st_size;    /* size in bytes, for regular files */
        struct timespec st_atim;    /* time of last access */
        struct timespec st_mtim;    /* time of last modification */
        struct timespec st_ctim;    /* time of last file status change */
        blksize_t   st_blksize; /* best I/O block size */
        blkcnt_t    st_blocks;  /* number of dis blocks allocated */
    };
```

st_rdev, st_blksize, and st_blocks fields are not required by POSIX.1. They are defined as part of XSI option in single UNIX Specification.

timespec structure type defines time in terms of seconds and nanoseconds. It includes at least the following fields:

```C
    time_t tv_sec;
    long tv_nsec;
```

Prior to 2008 version, the time fields were named st_atime, st_mtime, and st_ctime, and were time_t (expressed in seconds). timespec structure enables higher-resolution timestamps. Old names can be defined in terms of tv_sec member for compatibility. Example, st_atime can be defined as st_atim.tv_sec.

Most members of stat structure are specified by primitive system data type. Biggest user of stat functions is probably "ls -l" command to get information about a file.

## File types

We've talked about two types of files: regular files and directories. Most files on UNIX system are either regular or directories, but there are additional:

1. Regular file. Most common, contains data of some form. No distinction to UNIX kernel whether this data is text or binary. Any interpretation of contents of regular file is left to application processing the file. One exception are binary executable files. As kernel must understand format to execute it. So all binary executable files conform to a format that allows kernel to identify where to load program's text and data.
2. Directory file. File that contains names of other files and pointers to information on these file. Any process that has read permission for a directory can read contents of directory, but only kernel can write directly to a directory file. Processes must use functions described later to make changes to a directory.
3. Block special file. Type of file providing buffered I/O access in fixed-size units to devices such as disk drives. (FreeBSD no longer supports block special files. All access to devices is through characters special interface).
4. Character special file. Type of file providing unbuffered I/O access in variable-sized units to devices. All devices on a system are block special or character special files.
5. FIFO. Type of file used for communication between processes. Sometimes called named pipe. We describe FIFOs in Chapter 15.
6. Socket. Type of file used for network communication between processes. Socket can also be used for non-network communication between processes on single host. We use socket for interprocess communication in Chapter 16.
7. Symbolic link. Type of file that points to another.

Type of a file is encoded in st_mode member of stat structure. We can determine file type with macros:
    
    S_ISREG()   Regular file
    S_ISDIR()   Directory file
    S_ISCHR()   Character special file
    S_ISBLK()   Block special file
    S_ISFIFO()  pipe or FIFO
    S_ISLNK()   Symbolic link
    S_ISSOCK()  socket

Parameter of each macro is the st_mode member.

POSIX.1 allows implementations to represent interprocess communication (IPC) objects, suck as message queues and semaphores, as files. Next macros allow us to determine type of IPC object from stat structure. Instead of taking st_mode member as argument, these macros differ from previous in that their argument is a pointer to stat structure:

    S_TYPEISMQ()    message queue
    S_TYPEISSEM()   semaphore
    S_TYPEISSHM()   shared memory object

Discussed most in chapter 15. But None of implementations of these objects are as files in this book.

Example: [type_printer.c](https://github.com/K0deless/k0deless.github.io/blob/master/code/APUE/chapter4/type_printer.c) program which prints type of file for each command-line argument. 

Historically, early versions of UNIX System didn't provide S_ISxxx macros. Instead we had to AND the st_mode value with S_IFMT and then compare result with constants whose names are S_IFxxx. Most system define this mask and related constants in file <sys/stat.h>. If we examine this file, we'll find the S_ISDIR macro defined something like:

```C
    #define S_ISDIR(mode)   (((mode) & S_IFMT) == S_IFDIR)
```

Regular files are predominant, but it is interesting to see what percentage of files on given system are of each file type.

## Set-User-ID and Set-Group-ID

Every process has six or more IDs associated with it:

real user ID & real group ID = who we really are
effective user ID, effective group ID & supplementary group IDs = used for file access permission checks
saved set-user-ID & saved set-group-ID = saved by exec functions

* real user ID and real group ID identify who we really are. Taken from our entry in password file when we log in. Normally, values don't change during a login session, although there are ways for a superuser process to change them.
* effective user ID, effective group ID, and supplementary group IDs determine our file access permissions.
* Saved set-user-ID and saved set-group-ID contain copies of effective user ID and effective group ID, respectively when a program is executed. These were optional in older versions of POSIX. Application can test for constant *_POSIX_SAVED_IDS* at compile time or can call sysconf with *_SC_SAVED_IDS* argument at runtime, to see whether implementation supports this feature.

Normally, effective user ID equals real user ID, and effective group ID equals to real group ID. 
Every file has owner and a group owner. Owner is specified by st_uid member of stat structure; group owner, by st_gid member.
When we execute a program file, usually happen what we said about user and group ID. However we can set a special flag in file's mode word (st_mode) that says, "When file is executed, set effective user ID of process to be owner of the file (st_uid)." We can set another bit in file's mode word that causes effective group ID to be group owner of file (st_gid). These two bits in file's mode word are called set-user-ID bit and set-group-ID bit.

If owner of file is superuser and if file's set-user-ID bit is set, while program file is running as process, it has superuser privileges. And happens regardless of real user ID of process that executes the file. As example, UNIX System program that allows anyone to change his or her password, passwd(1), is set-user-ID program. Required so that program can write new password to file, typically /etc/passwd or /etc/shadow writable only by superuser. These kind of programs must be written carefully. We'll discuss these types of programs in more detail in Chapter 8.

Returning to stat function, set-user-ID bit and set-group-ID bit are contained in file's st_mode value. These two bits can be tested against constants S_ISUID and S_ISGID respectively.

## File Access Permissions

st_mode value also encodes access permission bits for file. When we say file, any type. There are nine permission bits for each file, divided into three categories:

|   type    |   meaning     |
|:---------:|:-------------:|
| S_IRUSR | user-read |
| S_IWUSR | user-write |
| S_IXUSR | user-execute |
| S_IRGRP | group-read |
| S_IWGRP | group-write |
| S_IXGRP | group-execute |
| S_IROTH | other-read |
| S_IWOTH | other-write |
| S_IXOTH | other-execute |

Term user in first three rows = owner of file. chmod command, typically used to modify these nine permission bits, allows us to specify 'u' for user (owner), g for group, and o for other. We'll use terms user, group and other, to be consistent with chmod.
The three categories - read, write, and execute - are used in various ways by different functions. We'll summarize them, and return when we describe the actual functions:

* first rule  is whenever we want to open any type of file by name, we must have execute permission in each directory mentioned in the name, including current directory. This is why execute permission bit for directory is often called search bit.
Example opening file /usr/include/stdio.h needs permission of execute in /, /usr and /usr/include, also necessary have specific permission in stdio.h depending we are opening file in read-only or read-write, etc.
If we are in /usr/include means we need execute permission in current directory to open file stdio.h.
Read permission for a directory and execute permission for a directory mean different things. Read permission lets us read directory, obtaining list of all filenames in directory. Execute permission lets us pass through directory when it's a component of a pathname we are trying to access.
Another example of implicit directory PATH environment variable, specifies directory that does not have execute permission enabled. This case, shell will never find executable files in that directory.
* read permission for a file determines whether we can open existing file for reading: O_RDONLY and O_RDWR flags for open fnuction.
* Write permission for a file determines whether we can open existing file for writing: O_WRONLY and O_RDWR flags for open function.
* We must have write permission for a file to specify O_TRUNC flag (as remove content).
* We cannot create new file in directory unless we have write permission and execute permission in directory.
* To delete existing existing file, we need write permission and execute permission in directory containing the file. We do not need read permission or write permission for file itself.
* Execute permission for a file must be on if we want to execute file using any of seven exec functions. File also has to be a regular file.

File access tests that kernel performs each time a process opens, creates, or deletes a file depend on owners of file (st_uid and st_gid), effective IDs of process (effective user ID and effective group ID), and supplementary group IDs of the process, if supported. Two owner IDs are properties of the file, whereas two effective IDs and supplementary group IDs are properties of the process. Test performed by kernel are as follows:
    * If effective user ID of process is 0 (superuser), access is allowed. This gives superuser free rein throughout entire file system.
    * If effective user ID of process equals owner ID of file (process owns file), access is allowed if appropiate user access permission bit is set. Otherwise, permission is denied. By appropiate access permission bit, we mean that if process is opening file for reading, user-read bit must be on. Same with writing and executing.
    * If effective group ID of process or one of supplementary group IDs of process equals group ID of the file, access is allowed if appropiate group access permission bit is set. Otherwise, permission is denied.
    * If appropiate other access permission bit is set, access is allowed. Otherwise, permission is denied.

These steps are tried in sequence. Note if process owns file (step 2), access is granted or denied based only on user access permissions; group permissions are never looked at. Similarly, if process does not won file but belongs to appropiate group, access is granted or denied based only on group access permissions; other permissions are not looked at.

## Ownership of New Files and Directories

We didn't say values assigned to created files (by open or creat) for the user ID and group ID. We'll see how to create a directory with mkdir. Rules for ownership of directory are the same than for a file.
User ID of new file is set to effective user ID of process. POSIX.1 allows an implementation to choose one of following options to determine group ID of new file:
    * Group ID of new file can be effective group ID of process.
    * Group ID of new file can be group ID of directory in which file is being created.
(FreeBSD 8.0 and Mac OS X 10.6.8 always copy new file's group ID from directory. Several Linux file system allow choice between two options to be selected using a mount command option, Linux 3.2.0 and Solaris 10 determine group ID if bit SGID (set-group-ID) is set new file's group ID is copied from directory; otherwise, new file's group ID is set to effective group ID of process).

Using second option, inheriting directory's group ID, assures us all files and directories created in that directory will have same group ID as directory. Group ownership of files and directories will then propagate down the hierarchy from that point.

## access and faccessat Functions

When we open a file, kernel performs its access test based on effective user and group IDs. Sometimes, a process wants to test accessibility based on real user and group IDs. Useful when a process is running as someone else, using set-user-ID or set-group-ID.
Even though  a process might be set-user-ID to root, it might still want to very that real user can access a given file. access and faccessat functions base their test on real user and group IDs.
```C
    #include <unistd.h>
    int access(const char *pathname, int mode);
    int faccessat(int fd, const char *pathname, int mode, int flag);
        Both return: 0 if OK, -1 on error.
```

mode is either value F_OK to test if file exists, or bitwise OR of any of next flags:

| Flag | Value |
|:----:|:-----:|
| R_OK | test for read permission |
| W_OK | test for write permission |
| X_OK | test for execute permission |

faccessat function behaves like access when pathname argument is absolute or when fd argument has value AT_FDCWD and pathname argument is relative. Otherwise, faccessat evaluates pathname relative to open directory referenced by fd argument.
flag argument can be used to change behaviour of faccessat. If AT_EACCESS flag is set, access checks are made using effective user and group IDs of calling process instead of real user and group IDs.

Example: [real_user_check.c](https://github.com/K0deless/k0deless.github.io/blob/master/code/APUE/chapter4/real_user_check.c), program that checks access of a file with the real user ID and real group ID using access call.

```command
    $ ./real_user_check /etc/spwd.db
    file exist
    access error for /etc/spwd.db: permission denied
    open error for /etc/spwd.db: permission denied
    $ sudo su
    # chown root real_user_check # set real_user_check ownser as root
    # chmod 4755 real_user_check # set SUID
    # exit
    $ ./real_user_check /etc/spwd.db
    file exist
    access error for /etc/spwd.db: permission denied
    open for reading OK
```

As we can see above, even with SUID, the function access uses the real user ID to check the access. 
In preceding example and in Chapter 8, we'll sometimes switch to become superuser to demonstrate how something works. If you're on multiuser system and do not have superuser permission, you won't be able to duplicate these examples completely.

## umask Function

Described the nine permission bits associated with every file, we can describe file mode creation mask associated with every process.
unask function sets file mode creation mask for process and returns previous value. (One of the few function that doesn't have error return).

```C
    #include <sys/stat.h>
    
    mode_t umask(mode_t cmask);
        Returns: previous file mode creation mask
```

cmask argument is formed as bitwise OR of any of nine constants from S_IRUSR, S_IWUSR, and so on.
File mode creation mask used whenever process creates new file or new directory (If we remember from chapter 3 in open and creat functions, both accept mode argument that specifies new file's access permission bits). We will see later how to create new directory. Any bits "on" in file mode creation mask are turned off in file's mode.

Example: [create_files_umask.c](https://github.com/K0deless/k0deless.github.io/blob/master/code/APUE/chapter4/create_files_umask.c) program that creates two files: one with umask of 0 (all permissions turned on), and one with umask that disables all group and other permission bits.
If we check the umask and execute the program we get the next information:

```command
    $ umask # check current file mode creation mask
    0022
    $ ./create_files_umask
    $ ls -l foo bar
    -rw-------  1 Fare9  Fare9     0B Feb  3 20:37 bar
    -rw-rw-rw-  1 Fare9  Fare9     0B Feb  3 20:37 foo
```

Most UNIX users never deal with umask value. They use the one set on login by shell's start-up file. When writing programs that create new files, if we want to ensure specific access permission bits are enabled, we must modify umask value while process is running. Example, if we want to ensure that anyone can read a file, we should set umask to 0. Otherwise, umask value is the one from system when process started.
We used shell's umask command to print file mode creation mask before we run program and after it completes. Changing file mode creation mask of a process doesn't affect mask of parent. All shells have a built-in umask command to set or print current file mode creation mask.
Users can set umask value to control default permissions on files they create. Value is expressed in octal, one bit representing one permission to be masked off. Permission can be denied setting corresponding bits. Some common umask values are 002 (prevent others from writing our files, or 022 prevent group members and others writing our files.
    
    Mask bit    Meaning
    0400        user-read
    0200        user-write
    0100        user-execute
    0040        group-read
    0020        group-write
    0010        group-execute
    0004        other-read
    0002        other-write
    0001        other-execute

Single UNIX specification requires that umask command support symbolic mode of operation. Unlike octal formta, symbolic format specifies permission are to be allowed (clear in file creation mask) instead of which one are to be denied (set in file creation mask). Check both forms below:

```command
    $ umask     # print current file mode creation mask
    002
    $ umask -S  # print symbolic form
    u=rwx,g=rwx,o=rx
    $ umask 027 # change file mode creation mask
    $ umask -S
    u=rwx,g=rx,o=
```

## chmod, fchmod and fchmodat Functions

these functions allow us to change file access permissions for existing file.

```C
    # include <sys/stat.h>

    int chmod (const char *pathname, mode_t mode);
    int fchmod (int fd, mode_t mode);
    int fchmodat (int fd, const char *pathname, mode_t mode, int flag);
        return: 0 if OK, -1 on error
```
chmod operates on specified file, and fchmod operates on file already opened. fchmodat behaves like chmod when pathname argument is absolute or when fd argument has value AT_FDCWD and pathname argument is relative. Otherwise, fchmodat evaluates pathname relative to open directory referenced by fd argument. flag argument can be used to change behaviour of fchmodat (when AT_SYMLINK_NOFOLLOW flag is set, chmodat doesn't follow symbolic links).
To change permission bits of file, effective user ID of process must be equal to owner ID of file, or process must have superuser permissions. mode is specified as bitwise OR of constants:

|   mode    |    Description    |
|:---------:|:------------------|
| S_ISUID   | set-user-ID on execution |
| S_ISGID   | set-group-ID on execution |
| S_ISVTX   | saved-text (sticky bit) |
| S_IRWXU   | read, write, and execute by user (owner) |
|   S_IRUSR | read by user (owner) |
|   S_IWUSR | write by user (owner) |
|   S_IXUSR | execute by user (owner) |
| S_IRWXG   | read, write, and execute by group |
|   S_IRGRP | read by group |
|   S_IWGRP | write by group |
|   S_IXGRP | execute by group |
| S_IRWXO   | read, write, and execute by others |
|   S_IROTH | read by others |
|   S_IWOTH | write by others |
|   S_IXOTH | execute by others |

These are the same bits that we explained previously but we've added the S_ISUID and S_ISGID, the S_ISVTX and the combination of the three permissions S_IRWXU, S_IRWXG, S_IRWXO.

Example: [change_file_permissions.c](https://github.com/K0deless/k0deless.github.io/blob/master/code/APUE/chapter4/change_file_permissions.c) In this file we will modify "bar" file previously created permissions (-rw------) for new one (rw-r--r--).

So if we check files and execute:

```command
    $ ls -lah bar foo
    -rw-------  1 Fare9  Fare9     0B Feb  3 20:37 bar
    -rw-rw-rw-  1 Fare9  Fare9     0B Feb  3 20:37 foo
    $ ./change_file_permissions
    $ ls -lah bar foo
    -rw-r--r--  1 Fare9  Fare9     0B Feb  3 20:37 bar
    -rw-rwSrw-  1 Fare9  Fare9     0B Feb  3 20:37 foo
```

So as we can see, we've modified permissions for "bar" and for foo we've modified files adding set-group-ID permission from previous mask of permission.

Note that time and date listed by "ls" command didn't change after program execution. chmod function updates only time that i-node was last changed. By default, ls -l lists time when contents of file were last modified (note difference between i-node time last modified and file content last modified).

chmod functions clear two of permission bits under following conditions:
* On systems, suck as Solares, if we try to set sticky bit (S_ISVTX) on regular file and do not have superuser privileges, sticky bit in mode is automatically turned off. To prevent malicious users from setting sticky bit and affecting system performance, only superuser can set sticky bit of regular file.
* Group ID of newly created file might potentially be a group that the calling process does not belong to. It's possible for group ID of new file to be group ID of parent directory. If the group ID of new file does not equal either the effective group ID of the process or one of the process's supplementary group IDs and if process does not have superuser privileges, then set-group-ID bit is automatically turned off. Prevents user from creating a set-group-ID file owned by group that user doesn't belong to.

## Sticky bit

Versions of UNIX System that predated demand paging, bit was known as sticky bit. If it was set for executable program file, first time program was executed, copy of program's text was saved in swap area when process terminated (code part). Program would then load into memory more quickly next time it was executed, because swap area was handled as contiguous file. Sticky bit was set for common application programs (text editor and passes of C compiler).
Right now this bit is not necessary with virtual memory and faster file system.
On contemporary systems, use of sticky bit has been extended. Single UNIX Specification allows sticky bit to be set for directory. If bit is set for directory, file in directory can be removed or renamed only if user has write permission for directory and meets one of following criteria:
* Owns the file
* Owns the directory
* Is the superuser
/tmp and /var/tmp are candidates for sticky bit (directories in which any user can typically create files). Permissions for these two directories are often read, write, and execute for everyone. But users should not be able to delete or rename files owned by others. (Latest versions of UNIX System referred this as saved-text bit).

## chown, fchown, fchownat and lchown Functions

functions allow us to change a file's user ID and group ID, but if either of arguments owner or group is -1, corresponding ID is left unchanged.
```C
    #include <unistd.h>

    int chown(const char *pathname, uid_t owner, gid_t group);
    int fchown(int fd, uid_t owner, gid_t group);
    int fchownat(int fd, const char *pathname, uid_t owner, gid_t group, int flag);
    int lchown(const char *pathname, uid_t owner, gid_t group);
        return: 0 if OK, -1 ok error
```

Four functions operate similar unless referenced file is a symbolic link. That case, lchown and fchownat (with AT_SYMLINK_NOFOLLOW flag set) change owners of symbolic link itself, not file pointed to by symbolic link.
fchown changes ownership of open file referenced by fd argument. Since it operates on file already open, it can't be used to change ownership of symbolic link.
fchownat behaves like chown or lchown when pathname argument is absolute or when fd argument has value AT_FDCWD and pathname argument is relative. Then if flag is AT_SYMLINK_NOFOLLOW it will act as lchown and as chown other case.
Historically BSD-based systems enforced restriction that only superuser can change ownership of a file. System V however, has allowed all users to change ownership of any files they own.

We can check constant _POSIX_CHOWN_RESTRICTED, so if the constant is in effect for specified file:
* Only superuser process can change user ID of file.
* Nonsuperuser process can change group ID of file if process owns the file (effective user ID equals user ID of file), owner is specified as -1 or equals user ID of file, and group equals either effective group ID of process or one of process's supplementary group IDs.

## File Size

st_size member of stat structure contains size of file in bytes. Field is meaningful only for regular files, directories and symbolic links.
For a regular file, file size of 0 is allowed. We'll get an end-of-file indication on first read of file. For a directory, file size is multiple of a number, such as 16 or 512 (we'll see it).
For symbolic link, file size is number of bytes in filename (symbolic link contains path to file, also symbolic links do not contain normal C null byte at the end of name).
Most contemporary UNIX systems provide fields st_blksize and st_blocks. First is preferred block size for I/O for file, and latter is actual number of 512-byte blocks allocated. Remember from chapter 3 that we encountered minimum amount of time required to read file when we used st_blksize for read operations. Standard I/O library (chapter 5), also tries to read or write st_blksize bytes at a time.

- Holes in a file
Regular file can contain "holes". Holes are creted by seeking past the current end of file and writing some data. read function returns data bytes of 0 for any byte positions that have not been written. If we execute "wc -c" in a file with holes, we will receive all characters read (counting holes too). That's the size "ls -l" give us too. But if we execute "du -s" in that file, we will receive the number of 512-byte blocks (less than size of file).

But if we create a copy using "cat file > file_copy", holes will be copied as null bytes, "ls -l" will return same size for both, but "du -s" will return a bigger number of blocks for the copy version will be bigger.

## File Truncation

We would like to truncate file by chopping off data at the end of file. Emptying a file, which we can do with O_TRUNC flag to open, is special case of truncation.

```C
    #include <unistd.h>

    int truncate(const char *pathname, off_t length);
    int ftruncate(int fd, off_t length);
        0 if OK, -1 on error
```

Both truncate existing file to length bytes. If previous size was greater than length, data beyond length is no longer accessible. If previous size was less than length, file size will increase and data between old end of file and newer will read as 0 (hole is probably created in the file).
ftruncate is used when we need to empty a file after obtaining a lock on the file.

## File Systems

Appreciate concept of links to file, we need understanding of the structure of UNIX file system. Understanding difference between i-node and directory entry that points to i-node is also useful.

Various UNIX implementations are in use today. Solaris, supports several types of disk file systems: BSD-derived UNIX file system (UFS), PCFS to read and write DOS-formatted diskettes, and HSFS to read CD file systems. UFS is based on Berkeley fast file system.

Each file system type has own characteristics features-some can be confusing. Most UNIX file systems support case-sensitive filenames. Mac OS X, however, the HFS file system is case-preserving with case-insensitive comparisons. So file.txt and file.TXT would be the same, one would overwrite the other. However, only the name used when the file was created is stored in file system (case-preserving aspect). Any permutation of upper and lowercase in "file.txt" characters will match searching for the file.

We can think of a disk drive being divided into one or more partitions. Each partition can contain a file system (Figure 4.13). And i-nodes are fixed-length entries that contain most of information about a file.

<img src="https://raw.githubusercontent.com/K0deless/k0deless.github.io/master/assets/img/Figure4_13.png">

Now if we examine i-node and data block portion of cylinder group in more detail, we have the next from Figure 4.14:

<img src="https://raw.githubusercontent.com/K0deless/k0deless.github.io/master/assets/img/Figure4_14.png">

Note following points:

- Two directory entries point to same i-node entry. Every i-node has link count that contains number of directory entries that point to it. Only when link count goes to 0 can the file be deleted (releasing data blocks of the file that are pointed by i-node). This is why operation of "unlinking a file" does not always mean "deleting the blocks associated with file". This is why function that removes a directory entry is called *unlink*, not delete. In stat structure, link count is contained in *st_nlink* member. Its primitive system data type is *nlink_t*. These types of links are called hard links, from Section 2.5.2 POSIX.1 constant LINK_MAX specifies maximum value for file's link count.
- Other type of link *symbolic link*. With a symbolic link, actual contents of file (data blocks) store name of the file that symbolic link points to. We can see some example with *ls* command, example filename in directory entry is string "lib" and the 7 bytes of data in file are usr/lib:

```console
    lrwxrwxrwx  1   root        7 Sep 25 07:14 lib -> usr/lib
```

- i-node contains all information about file: file type, file's access permissino bits, size of file, pointers to file's data blocks, etc. Most stat structure information is obtained from i-node. Only two items of interest are stored in directory entry: filename and i-node number (identifier in i-node array). Other items (length of filename and length of directory record) are not of interest. Data type for i-node number is ino_t.

- Because i-node number in directory entry points to an i-node in same file system, a directory entry can't refer to an i-node in different file system. This is why *ln* command can't cross file systems. We'll see it.
- Renaming a file without changing file systems, actual contents of file need not be moved, all that needs is to add new directory entry that points to existing i-node and then unlink old directory entry. Link count will remain the same. Example, renaming file /usr/lib/foo to /usr/foo, contents of file *foo* need not be moved if directories /usr/lib and /usr are on same file system. This is how *mv* command operates (for that reason cut-paste is faster than copying between same file system).


We've talked about concept of link count for regular file, but what about count field for a directory? Create new directory in working directory:

```console
    mkdir testdir
```

<img src="https://raw.githubusercontent.com/K0deless/k0deless.github.io/master/assets/img/Figure4_15.png">

i-node whose number is 2549 has a type field "directory" and a link count equal to 2 (as it is referenced in directory with i-node 1267 and in itself). Any leaf directory (directory that does not contain any other directories) always has a link count of 2 directory entry that names directory (testdir) and entry for dot ('.') in that directory. Directory with i-node number 1267 has a type field of "directory" and a link count greater than or equals to 3. As it is refereneced in itself (dot), in parent directory that gives its name (not showed in image) and from testdir dot-dot directory. Every subdirectory in parent directory causes parent directory's link count to be increased by 1.
Format is similar to classic format of UNIX file system (there are many references about this).

## link, linkat, unlink, unlinkat, and remove Functions

A file can have multiple directory entries pointing to its i-node. We can use *link* or *linkat* to create a link to existing file.

```C
    #include <unistd.h>
    int link (const char *existingpath, const char *newpath);
    int linkat(int efd, const char *existingpath, int nfd, const char *newpath, int flag);
        Both return: 0 if OK, -1 on error
```

Functions create new directory entry, *newpath*, that references existing file *existingpath*. If *newpath* exists, error is returned. Only name of *newpath* is  created. Rest of path must already exist.

With *linkat* function, existing file is specified by *efd* and *existingpath*, and new pathname is specified by *nfd* and *newpath*. If either pathname is relative, it is evaluated relative to corresponding file descriptor. If either file descriptor is set to AT_FDCWD, then pathname, if it's relative, is evaluated relative to current directory. If either pathname is absolute, file descriptor is ignored.

When existing file is symbolic link, flag argument of *linkat* is used to control if link to symbolic link or to file which symbolic link points is created. If AT_SYMLINK_FOLLOW flag is set in *flag*, link is created to target of symbolic link, otherwise link to symbolic link is created.

Creation of new directory entry and increment of link count must be atomic operation.

Most implementations require both pathnames be on same file system, although POSIX.1 allows implementation to support linking across file systems. If implementation supports creation of hard links to directories, it is restricted to only superuser. Constraint exists because such hard links can cause loops in file system, which most utilities that process file system aren't capable of handling. Many file system implementations disallow hard links to directories for this reason.

To remove existing directory entry, we call *unlink*:

```C
    #include <unistd.h>
    int unlink(const char *pathname);
    int unlinkat(int fd, const char *pathname, int flag);
        Both return: 0 if OK, -1 on error
```

Functions remove directory entry and decrement link count of file referenced by pathname. If there are other links to the file, data in the file is still accessible through other links. File is not changed if an error occurs.
To unlink a file, we must have WRITE permissions and EXECUTE permission in directory containing the directory entry. Also, if sticky bit is set in this directory we must have WRITE permission for the directory and meet one of following criteria:

- Own file
- Own directory
- Have superuser privileges

Only when link count reaches 0 can the contents be deleted. Other condition prevents contents of a file from being deleted: some process has file open. When a file is closed, kernel first checks count of number of processes that have file open. If count has reached 0, kernel then checks link count; if it's 0, file's content are deleted.

If *pathname* argument is relative, unlinkat function evaluates pathname relative to directory represented by *fd* file descriptor. If *fd* argument is set to AT_FDCWD, then pathname is evaluated relative to current working directory of calling process. If *pathname* argument is absolute pathname, then *fd* argument is ignored.

*flag* argument gives callers a way to change default behavior of *unlinkat*. When *AT_REMOVEDIR* flag is set, then *unlinkat* function can be used to remove a directory, similar to using *rmdir*. If flag is clear, unlinkat operates like unlink.

Example: [unlink_tempfile.c](https://github.com/K0deless/k0deless.github.io/blob/master/code/APUE/chapter4/unlink_tempfile.c), this program first it tries to open a temporary file called "tempfile" and if it exists, program unlinks it.

```console
    $ ls -l tempfile # look how big file is
    -rw-r-----  1   sar     413265408 Jan 21 07:14 tempfile
    $ df /home  # check how much free space is available
    Filesystem  1K-blocks       Used    Available   Use%    Mounted on
    /dev/hda4    11021440    1956332      9065108    18%    /home
    $ ./unlink_tempfile &   # run program in the background
    1364                    # shell prints its process ID
    $ fie unlinked          # file is unlinked
    ls -l tempfile          # see if filename is still there
    ls: tempfile: No such file or directory     # directory entry is gone
    $ df /home              # see if space is available yet
    Filesystem  1K-blocks       Used    Available   Use%    Mounted on
    /dev/hda4    11021440    1956332      9065108    18%    /home
    $ done                  # the program is done, all open files are closed
    df /home                # now disk space should be available
    Filesystem  1K-blocks       Used    Available   Use%    Mounted on
    /dev/hda4    11021440    1552352      9469088    15%    /home
    $ # now the 394.1 MB of disk space are available
```

This property of *unlink* is often used by program to ensure that temporary file it creates won't be left around in case programc rashes. Process creates a file using open or creat and then immediately calls *unlink*. File is not deleted, however, because it is still open. Only when process closes the file or terminates, causes kernel to close all its open files, file is deleted.
If *pathname* is symbolic link, *unlink* removes symbolic link, not file referenced by link. There's no function to remove file referenced by symbolic link given name of the link.

Superuser can call unlink with *pathname* specifying a directory if file system supports it, but function *rmdir* should be used instead to unlink a directory.
We can also unlink a file or directory with *remove* function. For a file, *remove* is identical to *unlink*. For a directory, *remove* is identical to *rmdir*.

```C
    #include <stdio.h>
    int remove (const char *pathname);
        Returns: 0 if OK, -1 on error
```

ISO C specifies remove function to delete a file. Name was changed from historical UNIX name of *unlink* because most non-UNIX system that implements the C standard didn't support the concept of links to a file at the time.

## rename and renameat Functions

File or directory is renamed with either the rename or renameat function.

```C
    #include <stdio.h>
    int rename (const char *oldname, const char *newname);
    int renameat (int oldfd, const char *oldname, int newfd, const char *newname);
        Both return: 0 if OK, -1 on error
```

Rename function is defined by ISO C for files (C standard doesn't deal with directories) POSIX.1 expanded definition to include directories and symbolic links.

Several conditions to describe for these functions, depending on whether *oldname* refers to a file, a directory, or symbolic link. We must also describe what happens if *newname* already exists.

1. *oldname* specifies file that it's not a directory, we're renaming a file or symbolic link. This case, if *newname* exists, it cannot refer to directory. If *newname* exists and is not a directory, it is removed, and *oldname* is renamed. We must have write permission for directory containing *oldname* and directory containing *newname*, since we change both directories.
2. *oldname* specifies a directory. If *newname* exists, it must refer to a directory, and must be empty (it contains only dot and dot-dot). If *newname* is an empty directory, it's removed, and *oldname* renamed. Additionally, when we rename a directory, *newname* cannot contain as a path prefix *oldname*. Example, we can't rename */usr/foo* to */usr/foo/testdir*, as foo cannot be removed to create new path.
3. If *oldname* or *newname* refers to symbolic link, link itself is processed, not file to which it resolves.
4. We can't rename dot or dot-dot. Neither dot nor dot-dot can appear as last component of *oldname* or *newname*.
5. Special case, if *oldname* and *newname* refer to same file, function returns successfully without changing anything (it would be stupid to process it).

Probably if *newname* exists and as we're removing a directory entry where *oldname* is, we need write permission and execute permission in the directory containing *oldname* and in the directory containing *newname*.

*renameat* function, same functionality as *rename* function, except when *oldname* or *newname* refers to relative pathname. If *oldname* specifies relative pathname, it is evaluated relative to directory referenced by *oldfd*. Same as *newname* if it's relative, it is evaluated relative to directory referenced by *newfd*. *oldfd* or *newfd* (or both) can be set to *AT_FDCWD* to evaluate corresponding pathname relative to current directory.

## Symbolic Links

Indirect pointer to a file, unlike hard links, which pointed directly to i-node of the file. Symbolic links were introduced to get around limitations of hard links.

* Hard links require link and file reside in same file system (normally).
* Only superuser can create hard link to a directory (when supported by underlying file system).

No file system limitations on symbolic link and what it points, anyone can create a symbolic link to a directory. Symbolic links typically used to "move" a file or entire directory hierarchy to another location on a system.
Using functions that refer to a file by name, we need to know whether function follows symbolic link. If function follows symbolic link, pathname argument to function refers to file pointed to by symbolic link. Otherwise, pathname argument refers to link itself, not file pointed. Next lists says which functions described in the chapter follow a symbolic link. Function mkdir, mkfifo, mknod and rmdir do not appear, as they return error when pathname is symbolic link. Also functions that take a file descriptor argument, such as fstat and fchmod, are not listed, as functions use a file descriptor commonly returned by a function which handles symbolic link. (Historically chown didn't follow symbolic links, but now does).

* Follows Symbolic link: access, chdir, chmod, chown, creat, exec, link, open, opendir, pathconf, stat, truncate.
* Does not follow symbolic link: lchown, lstat, readlink, remove, rename, unlink.

One exception to behavior of the lists, when *open* is called with O_CREAT and O_EXCL. In this case, if pathname refers to symbolic link, open will fail with errno set to EEXIST. Behavior is intented to close a security hole so privileged processes can't be fooled into writing to wrong files.

*Example*

It is possible to introduce loops into file system using symbolic links. Most functions that look up a pathname return errno of ELOOP when this occurs. Consider following commands:

```console
    $ mkdir foo                 # make new directory
    $ touch foo/a               # create 0-length file
    $ cd foo
    $ ln -s ../foo foo/testdir  # create a symbolic link
    $ ls -l foo
    total 0
    -rw-r-----  1   sar         0 Jan 22 00:16 a
    lrwxrwxrwx  1   sar         6 Jan 22 00:16 testdir -> ../foo
```

This creates a directory *foo* that contains file *a* and a symbolic link that points to *foo*. Figure 4.18 shows hierarchy, drawing directory as circle and file as square.

<img src="https://raw.githubusercontent.com/K0deless/k0deless.github.io/master/assets/img/Figure4_16.png">

If we use standard function *ftw* on Solaris to descend through file hierarchy, printing each pathname encontered, we would have as output:

```console
foo
foo/a
foo/testdir
foo/testdir/a
foo/testdir/testdir
foo/testdir/testdir/a
foo/testdir/testdir/testdir
foo/testdir/testdir/testdir/a

(many more lines until an ELOOP error)
```

We will see later, our own version of *ftw* that uses *lstat* instead of *stat* to prevent following symbolic links. (On Linux, *ftw* and *nftw* function records all directories seen and avoid processing a directory more than once, so they don't display this behavior).

Loop of this form is easy to remove. We can unlink file *foo/testdir* as unlink does not follow symbolic link. But if we create hard link that forms loop of this type, removal is much more difficult. This is why link function will not form a hard link to a directory unless process has superuser privileges.

When we open a file, if pathname passed to open specifies a symbolic link, open follows link to specified file. If file pointed to by symbolic link doesn't exist, open returns error saying it can't open the file. 

```console
    $ ln -s /no/such/file myfile        # create symbolic link
    $ ls myfile
    myfile                              # symbolic link exists
    $ cat myfile                        # try read file pointed
    cat: myfile: No such file or directory
    $ ls -l myfile                      # try -l option
    lrwxrwxrwx  1   sar         13 Jan 22 00:26 myfile -> /no/such/file
```

File *myfile* exists, but *cat* says there is no such file, because *myfile* is a symbolic link, cat uses *open* and file pointed to by symbolic link doesn't exist. The -l option to ls gives us two hints: first character is an l, which means symbolic link, and sequence -> also indicates a symbolic link. *ls* command has another option (-F) that appends an at-sign(@) to filenames that are symbolic links, which can help us spot symbolic links in directory listing without -l option.

## Creating and Reading Symbolic Links

To do this next functions are used:

```C
    #include <unistd.h>
    int symlink(const char *actualpath, const char *sympath);
    int symlinkat(const char *actualpath, int fd, const char *sympath);
        Both return: 0 if OK, -1 on error
```

New directory entry *sympath* created that points to *actualpath*. It's not required that *actualpath* exist when symbolic link is created. Also, *actualpath* and *sympath* need not to reside in same file system.

*symlinkat* function is similar to *symlink*, but sympath argument is evaluated relative to directory referenced by open file descriptor for that directory (specified by *fd* argument). If *sympath* argument specifies absolute pathname, or if *fd* argument has special value AT_FDCWD, *symlinkat* behaves same way as *symlink*.

Because *open* function follows a symbolic link, we need a way to open link itself and read name in link. *readlink* and *readlinkat* functions do this.

```C
    #include <unistd.h>
    ssize_t readlink(const char* restrict pathname, char *restrict buf, size_t
                     bufsize);
    ssize_t readlinkat(int fd, const char* restrict pathname,
                       char *restrict buf, size_t bufsize);
        Both return: number of bytes read if OK, -1 on error
```

Functions combine action of *open*, *read* and *close*. If successful, they return number of bytes placed into *buf*. Contents of symbolic link returned in *buf* are not null terminated.
*readlinkat* function behaves same way as *readlink* function when *pathname* argument specifies absolute pathname, or when *fd* argument has special value *AT_FDCWD*. However, when *fd* argument is valid file descriptor of an open directory and *pathname* argument is relative pathname, *readlinkat* evaluates pathname relative to open directory *fd*.

## File Times

We saw how 2008 version of Single UNIX Specification increased resolution of the time fields in *stat* structure from seconds to seconds plus nanoseconds. Actual resolution stored with each file's attributes depends on file system implementation. For file systems that store timestamps in second, nanoseconds fields will be filled with zeros. For file systems that store timestamps in a resolution higher than seconds, partial seconds value will be converted into nanoseconds and returned in nanoseconds fields.
Three time fields are maintained for each file

|   Field   |   Description     |   Example     |   ls(1) option    |
|:---------:|:------------------|:--------------|:-----------------:|
| st_atim | last-access time of file data | read | -u |
| st_mtim | last-modification time of file data | write | default |
| st_ctim | last-change time of i-node status | chmod, chown | -c |

Note difference between modification time (*st_mtim*) and changed status time (*st_ctim*). Modification time indicates when contents of file were last modified. Changed-status time indicates when the i-node of file was last modified. We've covered many operations that affect the i-node without changing actual contents of the file: changing file access permissions, changing user ID, changing number of links, and so on. Information of the i-node is stored separately from actual contents of file, we need changed-status time, in addition to modification time.
System does not maintain last-access time for an i-node. This is why functions *access* and *stat*, don't change any of three times. The access time is used by system administrators to delete files that have not been accessed for certain amount of time. For example files *a.out* or *core* not accessed in past week. *find* command oftend used for this type of operation.
The *ls* displays or sorts only on one of three time values. By default, when invoked with *-l* or *-t* option, it uses modification time of a file. The *-u* shows the access time, and *-c* option shows the changed-status time.
Next figure shows functions from this section, recall that a directory is simply a file containing directory entries: filenames and associated i-node numbers. Adding, deleting, or modifying directory entries can affect the three times associated with that directory. So for that reason next table contains one column for three times associated with file or directory, and other column for three times associated with parent directory of referenced file or directory. Example: creating new file affects directory that contains new file, and it affects i-node for new file. Reading or writing a file, affects only i-node of file and has no effect on directory.


<img src="https://raw.githubusercontent.com/K0deless/k0deless.github.io/master/assets/img/Figure4_20.PNG">

## futimens, utimensat, and utimes Functions

Several functions available to change access time and the modification time of a file. *futimens* and *utimensat* provide nanosecond granularity for timestamps, using *timespec* structure (same structure used by *stat* family).

```C
    #include <sys/stat.h>
    int futimens(int fd, const struct timespec times[2]);
    int utimensat(int fd, const char *path, const struct timespec times[2],
                int flag);
        Both return: 0 if OK, -1 on error
```

In both, first element of *times* array argument contains access time, and the second element contains the modification time. The two time values are calendar times, which count seconds since Epoch. Partial seconds are expressed in nanoseconds.

Timestamps can be specified in one of four ways:

1. *times* argument is null pointer. This case, both timestamps are set to current time.
2. *times* argument points to an array of two timespec structures. If *tv_nsec* field has special value *UTIME_NOW*, corresponding timestamp is set to current time. Corresponding *tv_sec* field is ignored.
3. *times* argument points to array of two *timespec* structures. If either *tv_nsec* field has special value *UTIME_OMIT*, then timestamp is unchanged. Corresponding *tv_sec* field is ignored.
4. *times* argument points to an array of two *timespec* structures and *tv_nsec* contains a value other than *UTIME_NOW* or *UTIME_OMIT*. In this case, corresponding timestamp is set to value specified by corresponding *tv_sec* and *tv_nsec* fields.

Necessary privileges depend on value of *times* argument.

* If *times* is a null pointer or if either *tv_nsec* is set to *UTIME_NOW*, the effective user ID of process must equal the owner ID of the file, process must have write permission for file, or process must be a superuser process.
* If *times* is non-null pointer and either *tv_nsec* has a value other than *UTIME_NOW* or *UTIME_OMIT*, effective user ID of process must equal the owner ID of the file, or process must be superuser process. Merely having write permission for the file is not adequate.
* If *times* is non-null pointer and both *tv_nsec* fields are set to *UTIME_OMIT*, no permissions checks are performed.

With *futimens* you need to open file to change its times. *utimensat* provides a way to change file's times using file's name. *pathname* argument is evaluated relative to *fd* argument, which is either a file descriptor of an open directory or special value *AT_FDCWD* to force evaluation relative to current directory of calling process. If *pathname* is an absolute pathname, *fd* argument is ignored.

*flag* argument to *utimensat* can be sued to further modify default behavior. If *AT_SYMLINK_NOFOLLOW* flag is set, then times of symbolic link itself are changed (if pathname refers to a symbolic link). Default behavior is to follow a symbolic link and modify times of file which link refers.

*futimens* and *utimensat* are included in POSIX.1. Third function, *utimes* is included in Single UNIX Specification as part of XSI option.

```C
    #include <sys/time.h>
    int utimes(const char *pathname, const struct timeval times[2]);
        Returns: 0 if OK, -1 on error
```

*utimes* function operates no pathname, *times* argument is a pointer to an array of two timestamps -acces time and modification time- but they are in seconds and microseconds:

```C
    struct timeval
    {
        time_t tv_sec;  /* seconds */
        long   tv_usec; /* microseconds */
    }
```

We are unable to specify av alue for changed-status time, *st_ctim* -time the i-node was last canged- this file is automatically updated when *utime* function is called.
On some versions of UNIX System, *touch* command, uses one of these functions. Also *tar* and *cpio* optionally call these functions to set a file's times to time values saved when file was archived.

Example: [silent_change.c](https://github.com/K0deless/k0deless.github.io/blob/master/code/APUE/chapter4/silent_change.c) this file truncate files to zero length using *O_TRUNC* option of *open* but does not change access time or modification time. To do this, program first obtains times with stat function, truncated the file, then resets times with *futimens* function.

The example can be seen in next image:

<img src="https://raw.githubusercontent.com/K0deless/k0deless.github.io/master/assets/img/example_silent_change.PNG">

## mkdir, mkdirat, and rmdir Functions

Directories created with *mkdir* and *mkdirat*, deleted with *rmdir*.

```C
    #include <sys/stat.h>
    int mkdir(const char *pathname, mode_t mode);
    int mkdirat(int fd, const char *pathname, mode_t mode);
        Both return: 0 ij OK, -1 on error
```

Used to create a new empty directory. Entries for dot and dot-dot are created automatically. Specified file access permissions *mode* are modified by file mode creation mask of the process.
Common mistake specify same *mode* as for a file: read and write permissions only. For a directory, we normally want at least one of the execute bits enabled, to allow access to filenames within directory (for directory listing at least) (Check previous exercises).

UserID and groupID of new directory are established according to rules described in section **Ownership of New Files and Directories**.

The *mkdirat* function similar to *mkdir* function. When *fd* argument has special value *AT_FDCWD*, or when *pathname* specifies absolute pathname, *mkdirat* behaves exactly like *mkdir*. Otherwise, *fd* argument is an open directory from which relative pathnames will be evaluated.

An empty directory is deleted with *rmdir*. An empty directory is one that contains only entries for dot and dot-dot.

```C
    #include <unistd.h>
    int rmdir(const char *pathname);
        Returns: 0 if OK, -1 on error
```

If link count of directory becomes 0 with this call, and if no other process has directory open, space occupied by directory is freed. If one or more processes have the directory open when the link count reaches 0, last link is removed, and dot and dot-dot entries are removed before this function returns. Additionally, no new files can be created in the directory. The directory is not freed, until last process closes it.

## Reading Directories

Directories can be read by anyone who has access permission to read directory. But only kernel can write to a directory, to preserve file system sanity. Recall from section **File Access Permission** that write permission bits and execute permission bits for a directory determine if we can create new files in directory and remove files from directory (it doesn't mean if we can write to directory itself).
Actual format of a directory depends on UNIX System implementation and the design of the file system. Version 7 had a simple structure: each directory entry was 16 bytes, 14 for filename and 2 for i-node number. When longer filenames were added to 4.2BSD, each entry became variable length, which means that any program that reads a directory is now system dependent. To simplify process of reading a directory, a set of directory routines were developed and are part of POSIX.1 Many implementations prevent applications from using *read* function to access the contents of directories, thereby further isolating applications from implementation-specific details of directory format.
As these structures manage strings and variable data sizes, it's necessary to use the standard functions in order to read strings from directory entries correctly, also avoid memory leakages, and so on.

```C
    #include <dirent.h>
    DIR *opendir(const char *pathname);
    DIR *fdopendir(int fd);
        Both return: pointer if OK, NULL on error 
    struct dirent *readdir(DIR *dp);
        Returns: pointer if OK, NULL at end of directory or error
    void rewinddir(DIR *dp);
    int closedir(DIR *dp);
        Returns: 0 if OK, -1 on error
    long telldir(DIR *dp);
        Returns: current location in directory associated with dp
    void seekdir(DIR *dp, long loc);
```

The *fdopendir* function first appeared in version 4 of Single UNIX Specification. It provides a way to convert an open file descriptor into a *DIR* structure for use by directory handling functions.
*telldir* and *seekdir* are not part of the base POSIX.1 standard. They are included in XSI option in Single UNIX Specification, so all conforming UNIX System implementations are expected to provide them.
The *dirent* structure defined in *<dirent.h>* is implementation dependent. But at least contain the following two members:

```C
    ino_t   d_ino;      /* i-node number */
    char    d_name[];   /* null-terminated filename */
```

*d_ino* entry is not defined by POSIX.1, because it is an implementation feature, but it is defined as part of XSI option in POSIX.1. POSIX.1 only defines *d_name*.

Size of *D_name* entry isn't specified, but it is guaranteed to hold at least *NAME_MAX* characters, not including terminating null byte. Since filename is null terminated, it doesn't matter how d_name is defined in header, because array size doesn't indicate length of filename.
The *DIR* structure is an internal structure used by seven functions to maintain information about directory being read. Purpose of *DIR* is similar to the one of *FILE* maintained by standard I/O library, described in next chapter.
Pointer to *DIR* structure returned by *opendir* and *fdopendir* is used with other five functions. The *opendir* function initializes things so first *readdir* returns first entry in the directory. When *DIR* structure is created by *fdopendir*, first entry returned by *readdir* depends on file offset associated with file descriptor passed to *fdopendir*. Ordering of entries within the directory is implementation dependent, and not usually alphabetical.

Example: [path_traverser.c](https://github.com/K0deless/k0deless.github.io/blob/master/code/APUE/chapter4/path_traverser.c) this program traverses a file hierarchy. Goal is to produce a count of various types of files shown in Figure 4.4. The program takes a single argument, the starting pathname, and recursively descends hierarchy from that point. Solaris for this provide the function *ftw* that performs actual traversal, but it follows the symbolic links because it uses *stat* so some files are counted twice, as a fix, Solaris provides an additional function *nftw*. Instead of using this tool, we will write our own.

## chdir, fchdir, and getcwd Functions

Every process has current working directory. Directory is where search for all relative pathnames start. When a user logs in to a UNIX system, current working directory normally start at directory specified by sixth field in */etc/passwd* file (user's home directory). Current working directory is an attribute of a process; home directory is an attribute of a login name.
We can change current working directory of calling process calling *chdir* of *fchdir*:

```C
    #include <unistd.h>

    int chdir(const char* pathname);
    int fchdir(int fd);
        Both return: 0 if OK, -1 on error
```

We can specify current working directory as a *pathname* or an open file descriptor.

Example: [change_chdir.c](https://github.com/K0deless/k0deless.github.io/blob/master/code/APUE/chapter4/change_chdir.c) Because it's an attribute of process, current working directory cannot affec processes tha invoke process that executes *chdir*. So the program written in here, it doesn't change at all any current directory for shell. So if we execute it:

```console
    $ pwd
    /usr/lib
    $ ./change_chdir
    chdir to /tmp succeeded
    $ pwd
    /usr/lib
```

Current working directory for the shell didn't change. This is a side effect of the way that shell executes programs. Each program is run in separate process, so current working directory of the shell is unaffected by call to *chdir* in the program. For this reason, *chdir* function has to be called directly from the shell, so *cd* command is built into the shells (IMPORTANT!!!).

Because kernel must maintain knowledge of current working directory, we should be able to fetch its current value. Kernel doesn't maintain full pathname of directory. Instead, kernel keeps information about directory, such as a pointer to directory's v-node. (Linux kernel can determine full pathname. Its components are distributed throughout mount table and dcache table, and are reassembled, example, when you read /proc/self/cwd symbolic link).
What we need is a function that starts at current working directory (dot) and works its way up directory hierarchy, using dot-dot to move up one level. At each level reads directory entries until it find name that corresponds to i-node at directory that it just came from. Repeating process until root is found. We have a function that do this for us:

```C
    #include <unistd.h>

    char *getcwd(char *buf, size_t size);
        Returns: buf if OK, NULL on error
```

We pass to the function address of a buffer *buf* and its *size* (in bytes). Buffer must be large enough to accommodate absolute pathname plus a terminating null byte, or else an error will be returning. (Some older implementations of *getcwd* allow first argument buf to be NULL, so function calls *malloc* to allocate *size* number of bytes dynamically. This is not POSIX.1 or Single UNIX Specification should be avoided).

Example: [get_current_dir.c](https://github.com/K0deless/k0deless.github.io/blob/master/code/APUE/chapter4/get_current_dir.c)  this program changes to a specific directory and then calls getcwd to print working directory.

In case of trying *chdir* follows symbolic link, but *getcwd* has no idea so it does not return symbolic link it returns the real path.

*getcwd* function useful when we have an application that needs to return location in file system where it started out. We can save starting location by calling *getcwd* before we change working directory. After we complete processing, we can pass pathname obtained to *chdir* to return to our starting location in file system.
*fchdir* function proces us with easy way to accomplish this task. Instead of calling *getcwd*, we can *open* current directory and save file descriptor before we change to a different location in file system.

## Device Special Files

Two fields *st_dev* and *st_rdev* are often confused. We'll use these in chapter 18 when we write *ttyname* function. Rules for their use are simple:

* Every file system known by its major and minor device numbers, encoded in primitive system data type *dev_t*. Major number identifies device driver and sometimes encodes which peripheral board to communicate with; minor number identifies specific subdevice. Figure 4.13 a disk drive often contains several file systems. Each file system on same disk drive would usually have same major number, but different minor number.
* We can access major and minor device numbers through two macros defined by most implementations: *major* and *minor*. We don't care how the two numbers are stored in a *dev_t* object. (POSIX.1 states that the dev_t type exists, but doesn’t define what it contains or how to get at its contents. The macros major and minor are defined by most implementations. Which header they are defined in depends on the system. They can be found in *<sys/types.h>* on BSD-based systems. Solaris defines their function prototypes in *<sys/mkdev.h>*, because the macro definitions in *<sys/sysmacros.h>* are considered obsolete in Solaris. Linux defines these macros in *<sys/sysmacros.h>*, which is included by *<sys/types.h>*.)
* *st_dev* value for every filename on a system is device number of file system containing filename and its corresponding i-node.
* Only character special files and block special files have a *st_rdev* value. Value contains device number for actual device.

Example: print_special_file.c (from the book, didn't compile because of major and minor functions)

```C
    #include "apue.h"

    #ifdef SOLARIS
    #include <sys/mkdev.h>
    # endif

    int
    main(int argc, char * argv[]) {
      int i;
      struct stat buf;
      for (i = 1; i < argc; i++) {
        printf("%s: ", argv[i]);
        if (stat(argv[i], & buf) < 0) {
          err_ret("stat error");
          continue;
        }
        printf("dev = %d/%d", major(buf.st_dev), minor(buf.st_dev));
        if (S_ISCHR(buf.st_mode) || S_ISBLK(buf.st_mode)) {
          printf(" (%s) rdev = %d/%d",
            (S_ISCHR(buf.st_mode)) ? "character" : "block",
            major(buf.st_rdev), minor(buf.st_rdev));
        }
        printf("\n");
      }
      exit(0);
    }
```

## Summary of File Access Permission Bits

We've covered all file access permission bits, some of which serve multiple purposes. Next figure summarizes these permission bits, and their interpretation when applied to a regular file and a directory:

<img src="https://raw.githubusercontent.com/K0deless/k0deless.github.io/master/assets/img/Figure4_26.PNG">

So Final nine constants can also be grouped into threes as follows:

S_IRWXU = S_IRUSR | S_IWUSR | S_IXUSR
S_IRWXG = S_IRGRP | S_IWGRP | S_IXGRP
S_IRWXO = S_IROTH | S_IWOTH | S_IXOTH

## Summary

Chapter has centered on *stat* function. We've gone through each member in *stat* structure in detail. This led us to examine all the attributes of UNIX files and directories. We've looked at how files and directories might be laid out in a file system, and we've seen how to navigate the file system namespace. A thorough understanding of all properties of files and directories and all the functions that operate on them is essential to UNIX programming.


# <a name="chapter5"></a> 5 - Standard I/O Library

## Introduction

This library is specified by ISO C standard, implemented on many operating systems other than UNIX System. Additional interfaces are defined as extensions to ISO C by Single UNIX Specification.

Standard I/O library handles details such as buffer allocation and performing I/O in optimal-sized chunks (obviating need to worry about using correct block size). Makes library easy to use, but introduces another set of problems.

## *Streams* and *FILE* Objects

We saw a little bit this on [Chapter3](#chapter3). When file is opened, file descriptor is returned, and descriptor is used for subsequent I/O operations. With standard I/O discussion centers on *streams*. When we open or create a file with standard I/O library, we've associated a stream with the file.

With ASCII, a single character is a single byte. With internation character sets, character can be more than one byte. Standard I/O streams can be used with single-byte and multibyte (or wide) characters. A stream's orientation determines whether characters are read and written are single or multibyte. When a stream is created has no orientation. If multibyte I/O function (*<wchar.h>*) is used on a stream without orientation, this is set to wide.  If byte  I/O function is used orientation is set to byte.
Only two functions can change orientation once set. Function *freopen* will clear a stream's orientation; *fwide* can be used to set stream's orientation.

```C
    #include <stdio.h>
    #include <wchar.h>
    int fwide (FILE *fp, int mode);
        Returns: positive if stream is wide oriented
                 negative if is byte oriented
                 0 if no orientation
```

*fwide* performs different tasks, depending on value of *mode* argument.

* If *mode* is negative, *fwide* will try to make specified stream byte oriented.
* If *mode* is positive, *fwide* will try to make specified stream wide oriented.
* If *mode* is zero, *fwide* will return value identifying stream's orientation.

*fwide* will not change orientation of a stream that is already oriented. Also there's no error return. So only thing we can do is to crear *errno* before calling *fwide* and check value after return. On the book we will deal only with byte-oriented streams.

When we open a stream, standard I/O function *fopen* retruns a pointer to *FILE* object. This is a structure that contains all information required by standard I/O library to manage the stream: file descriptor, pointer to a buffer for the stream, size of buffer, count of number of characters currently in the buffer, error flag, etc.
Application software should never need to examine *FILE* object, we pass *FILE* pointer as argument to each standard I/O function. We'll refer to a pointer to *FILE* object, type *FILE \**, as a *file pointer*.
We describe standard I/O library in context of a UNIX system. This library has been ported to a wide variety of other operating systems. We will talk about implementation on a UNIX system.

## Standard Input, Standard Output, and Standard Error

Three streams predefined and available to a process: standard input, output and error. These refer to same files as the file descriptors *STDIN_FILENO*, *STDOUT_FILENO* and *STDERR_FILENO*.
These three standard I/O streams are referenced through predefined file pointers *stdin*, *stdout*, *stderr*. File pointers are defined in *<stdio.h>*

## Buffering

Goal of buffering provided by standard I/O library is to use minimum number of *read* and *write* calls. Also library tries to do its buffering automatically for each I/O stream, obviating the need for application to worry about it. Unfortunately, single aspect of standard I/O library that generates most confusion is its buffering.
Three types of buffering are provided:

1. Fully buffered. Actual I/O takes place when standard I/O buffer is filled. Files residing on disk are normally fully buffered by standard I/O library. Buffer used is usually obtained by one of standard I/O functions calling *malloc* first time I/O is performed on a stream. Term *flush* describes writing of a standard I/O buffer. A buffer can be flushed by standard I/O routines, such as when buffer fills or we can call the function *fflush* to flush a stream. In UNIX environment, *flush* means two different things. In terms of standard I/O library, it means writing out the contents of a buffer, which may be partially filled. In terms of terminal driver, such as *tcflush* function, it means to discard data that's already stored in a buffer.

2. Line buffered. Standard I/O library performs I/O when a newline character is encountered on input or output. Allows us to output a single character at a time (with standard I/O *fputc*), knowing that actual I/O will take place only when we finish writing each line. Line buffering is used on a stream when it refers to a terminal (standard input and output). Line buffering comes with two caveats. First, size of buffer that standard I/O library uses to collect the line is fixed, so I/O might take place if we fill this buffer before writing a newline. Second, whenever input is requested through standard I/O library from an unbuffered stream or a line-buffered stream (that requires data to be requested from kernel) *all* line-buffered output streams are flushed. Reason for qualifier on line-buffered is that requested data may already be in buffer, which doesn't require data to be read from kernel. Obviously, any input from unbuffered stream, requires data to be obtained from kernel.

3. Unbuffered. Standard I/O does not buffer characters. If we write 15 characters with standard I/O *fputs* function, 15 characters are expected to be output as soon as possible, probably with *write* function we saw in chapter 3. Standard error stream, is normally unbuffered so any error messages are displayed as quickly as possible, regardless of whether they contain a newline.

ISO C requires following buffering characteristics:

* standard input and standard output fully buffered, if and only if they don't refer to an interactive device.
* standard error is nevery fully buffered.

This doesn't tell whether standard input and standard output are unbuffered or line buffered if they refer to an interactive device and whether standard error should be unbuffered or line buffered. Most implementations default to following types of buffering:

* Standard error always unbuffered.
* All other streams are line buffered if they refer to terminal device; otherwise, they are fully buffered.

This standard is the one used of the platform tested on this book.

We will explore standard I/O buffering later.

If we don't like defaults for any given stream, we can change buffering by calling *setbuf* or *setvbuf*:


```C

    #include <stdio.h>
    void setbuf(FILE *restrict fp, char *restrict buf);
    int setvbuf(FILE *restrict fp, char *restrict buf, int mode,
                size_t size);
        Returns: 0 if OK, nonzero on error
```

Functions must be called after stream has been opened, but before any other operation is performed on stream.

With *setbuf*, we can turn buffering on or off. To enable buffering, *buf* must point to a buffer of length *BUFSIZ*, constant defined in *<stdio.h>*. Normally stream is then fully buffered, but some systems may set line buffering if stream is associated with terminal device. To disable buffering, we set *buf* to *NULL*.

With *setvbuf*, we specify which type of buffering we want, done with *mode* argument, that can be:

* *_IOFBF fully buffered*
* *_IOLBF line buffered*
* *_IONBF unbuffered*

If we specify unbuffered stream , *buf* and *size* are ignored. If we specify fully buffered or line buffered, *buf* and *size* can optionally specify a buffer and its size. If stream is buffered and *buf* is NULL, standard I/O library will allocate its own buffer of the appropiate size for stream. By appropiate size, we mean value specified by *BUFSIZ*.

<img src="https://raw.githubusercontent.com/K0deless/k0deless.github.io/master/assets/img/Figure5_1.png">

If we allocate a standard I/O buffer as automatic variable within a function, we have to close the stream before returning from function (because it would be on the stack). Some implementations use part of buffer for internal bookkeeping, so actual number of bytes of data that can be stored in buffer can be less than *size* . We should let the system choose buffer size and allocate the buffer. When we do this, standard I/O library automatically releases buffer when we close the stream.
At any time, we can force a stream to be flushed.

```C
    #include <stdio.h>
    int fflush(FILE *fp);
        Returns: 0 if OK, EOF on error
```

*fflush* function causes any unwritten data for stream to be passed to kernel. As special case, if *fp* is *NULL*, *fflush* causes all output streams to be flushed.

## Opening a Stream

*fopen*, *freopen* and *fdopen* open a standard I/O stream.

```C
    #include <stdio.h>
    FILE *fopen(const char *restrict pathname, const char *restrict type);
    FILE *freopen(const char *restrict pathname, const char *restrict type,
                  FILE *restrict fp);
    FILE *fdopen(int fd, const char *type);
        All three return: file pointer if OK, NULL on errors
```

Differences in three functions:

1. *fopen* opens specified file.
2. *freopen* opens a specified file on specified stream, closing stream first if it is already open. If stream previously had an orientation *freopen* clears it. Function is typically used to open a specified file as one of predefined streams: standard input, standard output, or standard error.
3. *fdopen* takes existing file descriptor, which we could obtain from *open*, *dup*, *dup2*, *fcntl*, *pipe*, *socket*, *socketpair* or *accept*, and associates a standard I/O stream with descriptor. Used with descriptors returned by functions that create pipes and network communication channels. Because special type of files cannot be opened with standard I/O *fopen*, we have to call device-specific function to obtain a file descriptor, then associate stream using *fdopen*.

*fopen* and *freopen* are part of ISO C; *fdopen* is part of POSIX.1, since ISO C doesn't deal with file descriptors.

<img src="https://raw.githubusercontent.com/K0deless/k0deless.github.io/master/assets/img/Figure5_2.png">


ISO C specifies 15 values for *type* (From Figure 5.2) Using character b as part of *type* allows standard I/O  to differentiate between text file and binary file. As UNIX kernel doesn't differentiate between these types, specifying *b* as part of *type* has no effect.
With *fdopen*, meanings of *type* differ slightly. Descriptor has already been opened, so opening for writing does not truncate file. Also, standard I/O append mode cannot create file (since file has to exist if a descriptor refers to it).
When file is opened with type of append, each write will take place at current end of file. If multiple processes open same file with standard I/O append, data from each process will be correctly written to file.

(Old versions from *fopen* didn't handle append mode correctly, those version did *lseek* to end of file when stream was opened, to correctly support append mode when multiple processes are involved, file must be opened with *O_APPEND* flag, doing *lseek* before each write won't work).

When file is opened for reading and writing (plus sign in type), two restrictions apply:

* Output cannot be directly followed by input without intervening *fflush*, *fseek*, *fsetpos* or *rewind*.
* Input cannot be directly followed by output without intervening *fseek*, *fsetpos*, or *rewind*, or input operation that encounters end of file.

|   Restriction     | r | w | a | r+ | w+ | a+ |
|:------------------|:-:|:-:|:-:|:--:|:--:|:--:|
| file must already exist | + |   |   | + |   |   |
| previous contents of file discarded |   | + |   |   | + |   |
| stream can be read | + |   |   | + | + | + |
| stream can be written |   | + | + | + | + | + |
| stream can be written only at end |   |   | + |   |   | + |

If new file is created specifying type of *w* or *a*, we're not able to specify file's access permission bits, as we did with *open* or *creat* in Chapter3. POSIX.1 requires implementations to create file with following permission bit set:

*S_IRUSER | S_IWUSER | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH*

We can restrict permissions by adjusting our *umask* value.

An open stream is closed by calling *fclose*

```C
    #include <stdio.h>
    int fclose(FILE *fp);
        Returns: 0 if OK, EOF on error
```

Any buffered output data is flushed before file is closed. Any input data may be buffered is discarded. If standard I/O library had automatically allocated a buffer for stream, buffer is released.
When a process terminates normally, calling *exit* function or returning from *main*, all standards I/O streams with unwritten buffered data are flushed and all open standard I/O streams are closed.

## Reading and Writing a Stream

Once we open a stream, we chan choose three types of unformatted I/O:

1. Character-at-a-time I/O. Read one character at a time, with standard I/O functions handling all buffering, if stream is buffered.
2. Line-at-a-time I/O. Read or write a line at a time, we use *fgets* and *fputs*. Each line is terminated with newline character, and we have to specify maximum line length that we can handle when we call *fgets*.
3. Direct I/O. This type of I/O supported by *fread* and *fwrite* functions. For each I/O operation, we read or write some number of objects, where each object is of specified size. These functions are often used for binary files where we read or write a structure with each operation.

**Input Functions**

Three functions allow us to read one character at a time:

```C
    #include <stdio.h>
    int getc(FILE *fp);
    int fgetc(FILE *fp);
    int getchar(void);
        All three return: next character if OK, EOF on end of file or error.
```

Function *getchar* defined to be equivalent to *getc(stdin)*. Difference between *getc* and *fgetc* is *getc* can be implemented as a macro, and *fgetc* doesn't. This means 3 things:

1. Argument to *getc* should not be an expression with side effects, because it could be evaluated more than once.
2. *fgetc* is guaranteed to be a function, we can take its address. This allows us to pass address of *fgetc* as argument to another function.
3. Calls to *fgetc* probably take longer than calls to *getc*, as it usually takes more time to call a function.

These three functions return next character as *unsigned char* converted to *int*. Reason for specifying unsigned is so that high-order bit, if set, doesn't cause return value to be negative. Reason for requiring integer return value is that all possible character values can be returned, along with indication that either an error ocurred or end of file has been encountered. Constant *EOF* in *<stdio.h>* required to be a negative value (often -1). This representation also means that we cannot store return value from the three functions in a character variable and later compare value with *EOF*.

Note these functions return same value whether an error occurs or the end of file is reached. To distinguish between the two, we must call *ferror* or *feof*.

```C
    #include <stdio.h>
    int ferror(FILE *fp);
    int feof(FILE *fp);
        Both return: nonzero(true) if condition is true, 0 (false) otherwise
    void clearerr(FILE *fp);
```

In most implementations, two flags are maintained for each stream in FILE object:

* An error flag.
* An end-of-file flag.

Both are cleared calling *clearerr*.

After reading from a stream, we can push back characters calling *ungetc*.

```C
    #include <stdio.h>
    int ungetc(int c, FILE *fp);
        Returns: c if OK, EOF on error
```

Characters that are pushed back are returned by subsequent reads on stream in reverse order of their pushing. Although ISO C allows an implementation to support any amount of pushback, an implementation is required to provide only a single character of pushback.

Character that we push back does not have to be same character that was read. We are not able to push back *EOF*. When we reach end of file, however, we can push back a character. Next read will return that character, and read after read after that will return *EOF*. This works because successful call to *ungetc* clears end-of-file indication for the stream.

Pushback is often used when we're reading an input stream and breaking input into words or tokens. Sometimes we need to peek at next character to determine how to handle current character. It's then easy to pùsh back character that we peeked at, for next call to *getc* to return. If standard I/O library didn't provide this pushback capability, we would have to store character in a variable of our own, along with a flag telling us to use this character instead of calling *getc* next time we need a character.

**Output Functions**

Available that correspond to each of input functions we've already described.

```C
    #include <stdio.h>
    int putc  (int c, FILE *fp);
    int fputc (int c, FILE *fp);
    int putchar(int c);
        All three return: c if OK, EOF on error
```

*putchar* is equivalent to *putc(c, stdout)*, and *putc* can be implemented as a macro, whereas *fputc* cannot be implemented as a macro.

## Line-at-a-Time I/O

Provided by two functions, *fgets* and *gets*.

```C
    #include <stdio.h>
    char *fgets(char *restrict buf, int n, FILE *restrict fp);
    char *gets(char *buf);
        Both return: buf if OK, NULL on end of file or error.
```

Both specify address of buffer to read the line into. *gets* reads from standard input, whereas *fgets* reads from specified stream.
With *fgets*, we have to specify size of buffer, *n*, function reads up through and including next newline, but no more than *n-1* characters. Buffer is terminated with null byte. If line, including terminating newline, is longer than *n-1*, only partial line is returned, but buffer is always null terminated. Another call to *fgets* would be necessary.

**IMPORTANT TIP**

Never use *gets*. This function doesn't allow caller to specify buffer size. Allows buffer to overflow if line is longer than buffer, writing over whatever happens to follow buffer in memory.
Even if ISO C requires an implementation to provide *gets*, use *fgets*.

Line-at-a-time output is provided by *fputs* and *puts*.

```C
    #include <stdio.h>
    int fputs(const char *restrict str, FILE *restrict fp);
    int puts(const char *str);
        Both return: non negative value if OK, EOF on error.
```

Function *fputs* writes null-terminated string to specified stream. Null byte at the end is not written. This need not be line-at-a-time output, since string need not contain a newline as last non-null character. Usually, this is the case but not required.
*puts* function writes null-terminated string to standard output, without writing the null byte. But *puts* then writes newline character to standard output.
*puts* is not unsafe like its counterpart *gets*, but we'll avoid using it. If we always use *fgets* and *fputs*, we know that we already have to deal with newline character at end of each line.
